[{"title":"Hello World","url":"/2024/02/25/hello-world/","content":"这里芷若\n\n无论做什么事都喜欢和自己较劲\n\n身处这个快节奏的时代，强烈感觉自己的语言表达水平在不断的退化\n\n趁着寒假有时间 也是学校的一个活动 自己便搭建了这个博客\n\n以后不定期的会更新一些生活小记和学习笔记\n\n欢迎你的到访~"},{"title":"深拷贝与浅拷贝","url":"/2022/03/26/深拷贝与浅拷贝/","content":"\n## 两种数据类型：\n\n### 基础类型：数值、字符串、布尔、null、undefined\n\n```js\nvar a = =100;\nvar b = a;\na = 50;\nconsole.log(b);//100\n```\n\n基础类型，遇到 = 时，就是值的复制，存储地方在栈中\n\n![image-20220326185934901](../img/深拷贝与浅拷贝/image-20220326185934901.png)\n\n### 引用类型：统称为Object类型，细分有Object类型，Array类型，Date类型，Function类型等。\n\n```\nvar obj1={\n   a:1;\n}\nvar obj2 = obj1;\nobj2.a=2;\nconsole.log(obj1.a)\n```\n\n对象类型，遇到 = 时，是内存地址的复制，所以改变obj2的值，obj1也会跟着该表\n\n![image-20220326203505155](../img/深拷贝与浅拷贝/image-20220326203505155.png)\n\n## 深拷贝与浅拷贝\n\n**浅拷贝**：复制了地址，原来的变量和新建的变量指向了堆区的同一处地方，彼此会相互影响\n\n**深拷贝**：在堆区中重新分配内存，原来的变量和新的变量指向不同的地址，虽然值现在相同，但是互不影响\n\n#### 浅拷贝的实现方法：\n\n1. 对象之间直接用等号赋值\n\n   ```js\n   var obj1={\n      a:1;\n   }\n   var obj2 = obj1;\n   ```\n\n   \n\n2. 以下方法可以处理一层的深拷贝，但是如果对象里又嵌套了对象，则内层的对象依旧只复制了地址（浅拷贝）\n\n   - Object.assign()\n\n   ```js\n   var hd = {\n     name:\"小周\",\n     age:19\n   };\n   var obj = Object.assign({},hd);\n   ```\n\n   - 展开表达式\n\n   ```js\n   var hd = {\n     name:\"小周\",\n     age:19\n   };\n   var obj = {...hd};\n   ```\n\n   - 用for循环进行复制\n\n   ```js\n   var hd ={\n       name:\"小周\",\n           age: 19,\n   };\n   var obj = {};\n   for (const key in hd) {\n       obj[key] = hd[key];\n   }\n   ```\n\n   \n\n#### 深拷贝的实现方法：\n\n1. 手动进行复制。\n\n2. 将js对象先转化成json中的字符串，然后再转成js，就可以实现深拷贝\n\n   ```js\n   var json = JSON.stringify(obj1);\n   var js = JSON.parse(json);\n   ```\n\n   可也将两行代码合并成一行：\n\n   ```js\n   var obj2 = JSON.parse(JSON.stringify(obj));\n   ```\n\n   优点：简单方便\n\n   缺点：对象中的函数和正则表达式无法拷贝\n\n3. 递归\n\n   ```\n   function deepClone(newObj, obj) {\n       //遍历obj的每一个成员，赋值给newObj\n       for (var keys in obj) {\n           if (obj[key] instanceof Array) {\n               //数组，引用类型\n               newObj[key] = [];\n               deepClone(newObj[key], obj[key]);\n           }\n           else if (obj[key] instanceof Object) {\n               //对象：引用类型\n               newObj[key] = [];\n               deepClone(newObj[key], obj[key]);\n           }\n           else {\n               //值类型\n               newObj[key] = obj[key];\n           }\n       }\n   }\n   \n   ```\n\n   \n"},{"title":"flex布局","url":"/2022/03/23/flex布局/","content":"\n## 布局原理\n\nflex是flexible Box 的缩写，是弹性布局的意思。\n\n- 块级元素和行内元素可以指定为flex布局\n- 将父元素设置为flex布局后，子元素的浮动，清除浮动，vertical-align的属性都会失效\n- 父元素称为“容器”，子元素称为“项目”，子元素可以横向排列也可以纵向排列\n\n通过给父元素增加flex属性来控制子元素的位置和排列方式\n\n\n\n**注意**：\n\n以下所有属性的演示都是基于以下HTML\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<style>\n    div{\n        display: flex; \n        width:800px;\n        height: 300px;\n        background-color: #74c0fc;\n    }\n    \n    div span{\n        width: 150px;\n        height: 100px;\n        background-color: #1c7ed6;\n    }\n</style>\n<body>\n    <div>\n        <span>1</span>\n        <span>2</span>\n        <span>3</span>\n    </div>\n</body>\n</html>\n```\n\n**初始界面：**\n\n![image-20220323213110551](../img/flex布局/image-20220323213110551.png)\n\n- 设置主轴方向：flex-direction\n\n  | 属性值         | 主轴方向                 |\n  | -------------- | ------------------------ |\n  | row            | 系统**默认值**，从左到右 |\n  | row-reverse    | 从右到左                 |\n  | column         | 从上到下                 |\n  | column-reverse | 从下到上                 |\n\n- 设置主轴上子元素的排列方式: justify-content \n\n  | 属性值        | 子元素的排列方式                                    |\n  | ------------- | --------------------------------------------------- |\n  | flex-start    | 系统**默认值**，从头开始，如果主轴为x轴，则从左到右 |\n  | flex-end      | 从尾部开始排列                                      |\n  | center        | 从主轴居中对齐（若主轴是x轴则元素水平居中）         |\n  | space-around  | 平分剩余空间                                        |\n  | space-between | 两边贴边，再平分剩余空间                            |\n\n  \n\n## 父项属性\n\n### 设置主轴的方向：flex-direction  \n\n子元素跟着主轴来排列\n\n`flex-direction:row; ` 默认，子元素从左到右排列\n\n![image-20220323213728101](../img/flex布局/image-20220323213728101.png)\n\n`flex-direction:row-reverse;`   子元素从右到左排列\n\n![image-20220323213753046](../img/flex布局/image-20220323213753046.png)\n\n`flex-direction:column; ` 子元素从上到下排列\n\n![image-20220323213813801](../img/flex布局/image-20220323213813801.png)`flex-direction:column-reverse；`子元素从下向上排列\n\n![image-20220323213905360](../img/flex布局/image-20220323213905360.png)\n\n### 设置主轴上子元素的排列方式: justify-content \n\n`justify-content ：flex-start`\n\n![image-20220323214852302](../img/flex布局/image-20220323214852302.png)`justify-content ：flex-end`\n\n这里注意区分与`flex-direction:row-reverse;`的区别，这个的元素依旧是从左向右的方向的，只不过靠右紧贴\n\n![image-20220323215031321](../img/flex布局/image-20220323215031321.png)\n\n`justify-content :center`\n\n![image-20220323215241090](../img/flex布局/image-20220323215241090.png)\n\n`justify-content ：space-around`\n\n![image-20220323215351121](../img/flex布局/image-20220323215351121.png)\n\n`justify-content ：space-between`\n\n![image-20220323215414603](../img/flex布局/image-20220323215414603.png)\n\n### 设置侧轴上的子元素的排列方式：align-items（单行）\n\n**注意**，该属性只能在子元素只有单行的时候才可以\n\n控制子元素在侧轴（默认是y轴）上的排列方式\n\n`align-items:flex-start`:默认值，从上到下排列\n\n![image-20220323220839174](../img/flex布局/image-20220323220839174.png)\n\n`align-items:center`:居中\n\n![image-20220323221003410](../img/flex布局/image-20220323221003410.png)\n\n`align-items:flex-end`:从下到上排列\n\n![image-20220323221028283](../img/flex布局/image-20220323221028283.png)\n\n### 设置侧轴上的子元素的排列方式：align-content（多行）\n\n**注意**：该属性只有在子元素换行的时候才可以使用，即使用该属性首先要`flex-wrap:wrap`.\n\n`align-content:flex-start;`默认值，从侧轴的头部开始排列\n\n![image-20220323222102413](../img/flex布局/image-20220323222102413.png)\n\n`align-content:center;`默认值，从侧轴的中间显示\n\n![image-20220323222144296](../img/flex布局/image-20220323222144296.png)\n\n`align-content:space-around;`子元素在侧轴评分剩余元素\n\n`align-content:space-between;`子元素在侧轴先分布在两头，在平分剩余空间\n\n`align-content:stretch`:子元素不设置高度，子严肃的高度评分父元素高度\n\n### 设置子元素是否换行 ：flex-wrap\n\n在演示这个属性，为了清楚，我给子元素增加了左外边距\n\n![image-20220323215951913](../img/flex布局/image-20220323215951913.png)\n\n我又增加了3个子元素\n\n![image-20220323220019157](../img/flex布局/image-20220323220019157.png)\n\n`flex-wrap:nowrap`(默认不换行，如果父元素一行内子元素放不下，会自动缩小子元素的宽度)\n\n可以发现，增加了子元素之后一行明显放不下了，所以系统默认将子元素的宽度缩小了。\n\n`flex-wrap:wrap`\n\n![image-20220323220132789](../img/flex布局/image-20220323220132789.png)\n"},{"title":"链表第一次作业","url":"/2022/03/18/链表第一次作业/","content":"\n## 问题 B: 链表排序\n\n### 题目描述\n\n已知一个正整数组成的无序序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后将这个链表进行排序，使得排序后的链表为递增序列。正整数的输入用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。在排序的过程中，你可以自己选择排序算法（冒泡排序、选择排序等），但必须是通过修改结点的指针域来进行排序，而不是对结点的数据域进行修改。程序结束后要释放所有节点占据的空间。\n\n### 输入\n\n一个元素个数未知的正整数序列，以输入“-1”结束，输入“-1”前至少输入一个正整数。\n\n### 输出\n\n经过排序后的链表，**每个元素后有一个空格，注意最后一个元素后只有换行符。**\n数据最多的测试用例节点数在1000这个数量级，所有整数可以用int型存储。\n\n### 样例输入\n\n```\n49 38 65 97 76 13 27 49 -1\n```\n\n### 样例输出 \n\n```\nThe new list is:13 27 38 49 49 65 76 97\n```\n\n### 我的代码：\n\n```c++\n#include<iostream>\nusing namespace std;\n\nstruct ListNode {\n\tint val;\n\tListNode* next;\n\tListNode():val(0),next(nullptr){}\n    ListNode(int x):val(x),next(nullptr){}\n\tListNode(int x,ListNode *next):val(x),next(next){}\n};\n//链表排序\nListNode* sortList(ListNode* head) {\n    //递归终止条件:cut到每一部分只剩下1个结点或0个结点\n\tif (head == NULL || head->next == NULL)\n\t\treturn head;\n\t//利用快慢指针找到链表的中点（slow)\n\tListNode* fast = head->next;\n\tListNode* slow = head;\n\twhile (fast != NULL && fast->next != NULL) {\n\t\tfast = fast->next->next;\n\t\tslow = slow->next;\n\t}\n\t//记录后一段的头结点\n\tListNode* nextHead = slow->next;\n\t//断开链表\n\tslow->next = nullptr;\n\t//继续递归cut\n\tListNode* left = sortList(head);\n\tListNode* right = sortList(nextHead);\n\n\t//合并\n\t//建立哑结点\n\tListNode* dummy = new ListNode;\n\t//cur不断后移扩充链表\n\tListNode* cur = dummy;\n\t//利用双指针合并\n\twhile (left && right) {\n\t\tif (left->val < right->val) {\n\t\t\tcur->next = left;\n\t\t\tleft = left->next;\n\t\t}\n\t\telse {\n\t\t\tcur->next = right;\n\t\t\tright = right->next;\n\t\t}\n\t\tcur = cur->next;\n\t}\n\tcur->next = left ? left : right;\n\treturn dummy->next;\n\n}\n\n//输出链表的值\nvoid print(ListNode* head) {\n\tcout << \"The new list is:\";\n\twhile (head) {\n\t\tif (head->next) {\n\t\t\tcout << head->val << \" \";\n\t\t}\n\t\telse {\n\t\t\tcout << head->val << endl;\n\t\t}\n\t\thead = head->next;\n\t}\n}\n\nint main() {\n\t//尾插法\n\tListNode* head = new ListNode;\n\tListNode* tail = head;\n\tint x = 0;\n\tcin >> x;\n\twhile (x != -1) {\n\t\tListNode* temp = new ListNode;\n\t\ttemp->val = x;\n\t\ttail->next = temp;\n\t\ttail = temp;\n\t\tcin >> x;\n\t}\n\tsortList(head);\n\tprint(head->next);\n\treturn 0;\n}\n\t\n\t5 -1\n        \n```\n\n## 问题C\n\n我也不知道我错哪里了，好吧通过讨论群里麦神的提示我知道了，\n\n只需要把`while(str[0]  != '-')`改成`while (str.compare(\"-1\"))` 就行了!🤦‍♀️枯了\n\n```c++\n#define _CRT_SECURE_NO_WARNINGS 1\n#include<iostream>\n#include <ctype.h>\nusing namespace std;\n\nstruct ListNode {\n\tchar val;\n\tListNode* next;\n\tListNode():val(0),next(nullptr){}\n    ListNode(int x):val(x),next(nullptr){}\n\tListNode(int x,ListNode *next):val(x),next(next){}\n};\n//链表排序\nListNode* sortList(ListNode* head) {\n    //递归终止条件:cut到每一部分只剩下1个结点或0个结点\n\tif (head == NULL || head->next == NULL)\n\t\treturn head;\n\t//利用快慢指针找到链表的中点（slow)\n\tListNode* fast = head->next;\n\tListNode* slow = head;\n\twhile (fast != NULL && fast->next != NULL) {\n\t\tfast = fast->next->next;\n\t\tslow = slow->next;\n\t}\n\t//记录后一段的头结点\n\tListNode* nextHead = slow->next;\n\t//断开链表\n\tslow->next = nullptr;\n\t//继续递归cut\n\tListNode* left = sortList(head);\n\tListNode* right = sortList(nextHead);\n\n\t//合并\n\t//建立哑结点\n\tListNode* dummy = new ListNode;\n\t//cur不断后移扩充链表\n\tListNode* cur = dummy;\n\t//利用双指针合并\n\twhile (left && right) {\n\t\tif (left->val < right->val) {\n\t\t\tcur->next = left;\n\t\t\tleft = left->next;\n\t\t}\n\t\telse {\n\t\t\tcur->next = right;\n\t\t\tright = right->next;\n\t\t}\n\t\tcur = cur->next;\n\t}\n\tcur->next = left ? left : right;\n\treturn dummy->next;\n\n}\n\n//输出链表的值\nvoid print(ListNode* head,char ch) {\n\tif (head == NULL) {\n\t\tif (ch != 'C') {\n\t\t\tcout << \"There is no item in \" << ch << \" list.\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"There is no item in \" << ch << \" list.\";\n\t\t}\n\t\treturn;\n\t}\n\tcout << \"The list \"<<ch<<\" is: \";\n\twhile (head) {\n\t\tif (head->next) {\n\t\t\tcout << head->val << \" \";\n\t\t}\n\t\telse {\n\t\t\tcout << head->val << endl;\n\t\t}\n\t\thead = head->next;\n\t}\n}\n\n//分割链表\nvoid cut(ListNode* head,ListNode*A,ListNode*B,ListNode*C) {\n\tListNode* temp = head;\n\tListNode* tempA = A;\n\tListNode* tempB = B;\n\tListNode* tempC = C;\n\twhile (temp->next) {\n\t\tif (isalpha(temp->next->val)) {\n\t\t\ttempA->next = temp->next;\n\t\t\ttemp->next = temp->next->next;\n\t\t\ttempA = tempA->next;\n\t\t}\n\t\telse if (isdigit(temp->next->val)) {\n\t\t\ttempB->next = temp->next;\n\t\t\ttemp->next = temp->next->next;\n\t\t\ttempB = tempB->next;\n\t\t}\n\t\telse {\n\t\t\ttempC->next = temp->next;\n\t\t\ttemp->next = temp->next->next;\n\t\t\ttempC = tempC->next;\n\t\t}\n\t}\n\ttempA->next = nullptr;\n\ttempB->next = nullptr;\n\ttempC->next = nullptr;\n}\n\nint main() {\n\t//尾插法\n\tListNode* head = new ListNode;\n\tListNode* tail = head;\n\tstring str ;\n\tcin >> str;\n\twhile (str[0]  != '-') {\n\t\tListNode* temp = new ListNode;\n\t\ttemp->val = str[0];\n\t\ttail->next = temp;\n\t\ttail = temp;\n\t\tcin >> str;\n\t}\n\tListNode* A = new ListNode;\n\tListNode* B = new ListNode;\n\tListNode* C = new ListNode;\n\tcut(head,A,B,C);\n\tsortList(A);\n\tsortList(B);\n\tsortList(C);\n\tprint(A->next,'A');\n\tprint(B->next,'B');\n\tprint(C->next,'C');\n\n\treturn 0;\n}\n\t\n\t\n```\n\n### 问题D\n\n我还是不知道自己错那了\n\n嘿嘿，找出一个错误，是没有判断A比B短的情况，增加了之后变成90分了\n\n```c++\n#define _CRT_SECURE_NO_WARNINGS 1\n#include<iostream>\nusing namespace std;\n\nstruct ListNode {\n\tint val;\n\tListNode* next;\n\tListNode() :val(0), next(nullptr) {}\n\tListNode(int x) :val(x), next(nullptr) {}\n\tListNode(int x, ListNode* next) :val(x), next(next) {}\n};\n\nint  get(ListNode* head, ListNode* tail) {\n\tint count = 0;\n\tint x = 0;\n\tcin >> x;\n\twhile (x != -1) {\n\t\tListNode* temp = new ListNode;\n\t\tcount++;\n\t\ttemp->val = x;\n\t\ttail->next = temp;\n\t\ttail = temp;\n\t\tcin >> x;\n\t}\n\treturn count;\n}\nbool cmp(ListNode* h1, ListNode* h2) {\n\tListNode* i = h1;\n\twhile (i) {\n\t\tListNode* j = h2;\n\t\tListNode* k = i;\n\t\twhile (j) {\n\t\t\tif (k->val == j->val) {\n\t\t\t\tk = k->next;\n\t\t\t\tj = j->next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti = i->next;\n\t\tif (j == nullptr) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\t//尾插法\n\tListNode* head1 = new ListNode;\n\tListNode* tail1 = head1;\n\tListNode* head2 = new ListNode;\n\tListNode* tail2 = head2;\n\tint count1= get(head1, tail1);\n\tint count2=get(head2, tail2);\n\tif (count2 > count1) {\n\t\tcout << \"ListB is not the sub sequence of ListA.\";\n\t\treturn 0;\n\t}\n\tbool ret = cmp(head1->next, head2->next);\n\tif (ret) {\n\t\tcout << \"ListB is the sub sequence of ListA.\";\n\t}\n\telse {\n\t\tcout << \"ListB is not the sub sequence of ListA.\";\n\t}\n\treturn 0;\n}\n```\n\n## 问题E\n\n✌耶耶耶我一遍过了\n\n```c++\n#define _CRT_SECURE_NO_WARNINGS 1\n#include<iostream>\nusing namespace std;\n\nstruct ListNode {\n\tint val;\n\tListNode* next;\n\tListNode() :val(0), next(nullptr) {}\n\tListNode(int x) :val(x), next(nullptr) {}\n\tListNode(int x, ListNode* next) :val(x), next(next) {}\n};\n\nvoid func(ListNode* head,int s1,int t1,int s2,int t2){\n\tListNode* cur = head;\n\tint count = 0;\n    //记录几个重要节点\n\twhile (count != s1 - 1) {\n\t\tcur = cur->next;\n\t\tcount++;\n\t}\n\tListNode* pre1 = cur;\n\tListNode* x1 = cur->next;\n\twhile (count != t1) {\n\t\tcur = cur->next;\n\t\tcount++;\n\t}\n\tListNode* nex1 = cur;\n\twhile (count != s2 - 1) {\n\t\tcur = cur->next;\n\t\tcount++;\n\t}\n\tListNode* pre2 = cur;\n\twhile (count != t2) {\n\t\tcur = cur->next;\n\t\tcount++;\n\t}\n\tListNode* nex2 = cur;\n\tListNode* y2 = cur->next;\n     \n    //交换节点\n    //注意这里要分两种情况\n    //1.两个区间挨在一起，如[1,2] [3,6],即左区间的右边就是右区间\n    //2.两个区间没有挨在一起，如[1,2] [5,6]\n\t\n    pre1->next = pre2->next;\n\tif (t1 + 1 == s2) {\n\t\tnex2->next = x1;\n\t}\n\telse {\n\t\tnex2->next = nex1->next;\n\n\t\tpre2->next = x1;\n\t}\n\tnex1->next = y2;\n}\n//打印链表\nvoid print(ListNode* head) {\n\tcout << \"The new list is:\";\n\twhile (head) {\n\t\tif (head->next) {\n\t\t\tcout << head->val << \" \";\n\t\t}\n\t\telse {\n\t\t\tcout << head->val << endl;\n\t\t}\n\t\thead = head->next;\n\t}\n}\nint main() {\n\t//尾插法\n\tListNode* head = new ListNode;\n\tListNode* tail = head;\n\tint x = 0;\n\tcin >> x;\n\twhile (x != -1) {\n\t\tListNode* temp = new ListNode;\n\t\ttemp->val = x;\n\t\ttail->next = temp;\n\t\ttail = temp;\n\t\tcin >> x;\n\t}\n\tint s1, t1, s2, t2;\n\tcin >> s1 >> t1 >> s2 >> t2;\n\tfunc(head,s1,t1,s2,t2);\n\tprint(head->next);\n\treturn 0;\n}\n```\n\n## 问题F\n\n```c++\n#define _CRT_SECURE_NO_WARNINGS 1\n#include<iostream>\nusing namespace std;\n\nstruct ListNode {\n\tint val;\n\tListNode* next;\n\tListNode() :val(0), next(nullptr) {}\n\tListNode(int x) :val(x), next(nullptr) {}\n\tListNode(int x, ListNode* next) :val(x), next(next) {}\n};\n\nvoid get(ListNode* head, ListNode* tail) {\n\tint x = 0;\n\tcin >> x;\n\twhile (x != -1) {\n\t\tListNode* temp = new ListNode;\n\t\ttemp->val = x;\n\t\ttail->next = temp;\n\t\ttail = temp;\n\t\tcin >> x;\n\t}\n\ttail->next = nullptr;\n}\n\nvoid merge(ListNode* h1, ListNode* h2) {\n\tif (h1->next == nullptr || h2->next == NULL) {\n\t\treturn;\n\t}\n\tListNode* cur1 = h1;\n\tListNode* cur2 = h2;\n\twhile (cur1->next && cur2->next) {\n\t\tListNode* nex2 = cur2->next;\n\t\tif (cur1->val<nex2->val && cur1->next->val>nex2->val) {\n\t\t\tcur2->next = cur2->next->next;\n\t\t\tnex2->next = cur1->next;\n\t\t\tcur1->next = nex2;\n\n\t\t}\n\t\tcur1 = cur1->next;\n         while (cur2->next&&cur1->val == cur2->next->val)\n\t\t\t\tcur2 = cur2->next;\n\t}\n\tif (cur2->next) {\n\t\tcur1->next = cur2->next;\n\t\tcur2->next = nullptr;\n\t}\n\n}\n//输出链表的值\nvoid print(ListNode* head, char ch) {\n\tif (head == NULL) {\n\t\tcout << \"There is no item in \" << ch << \" list.\" << endl;\n\t\treturn;\n\t}\n\tcout << \"The list \" << ch << \" is: \";\n\twhile (head) {\n\t\tif (head->next) {\n\t\t\tcout << head->val << \" \";\n\t\t}\n\t\telse {\n\t\t\tcout << head->val << endl;\n\t\t}\n\t\thead = head->next;\n\t}\n}\nint main() {\n\t//尾插法\n\tListNode* head1 = new ListNode;\n\tListNode* tail1 = head1;\n\tListNode* head2 = new ListNode;\n\tListNode* tail2 = head2;\n\tget(head1, tail1);\n\tget(head2, tail2);\n\tmerge(head1, head2);\n\tprint(head1->next, 'A');\n\tprint(head2->next, 'B');\n\treturn 0;\n\n}\n```\n\n","tags":["作业"]},{"title":"手把手教你写贪吃蛇👩‍🔧(原生JS)","url":"/2022/03/16/贪吃蛇/","content":"\n## 手把手教你写贪吃蛇👩‍🔧\n\n## ①绘制界面\n\n### 设置分数和速度\n\n```html\n    <h1>score:</h1>\n    <button>快</button>\n    <button>中</button>\n    <button>慢</button>\n\n```\n\n分数字体大，采用h1\n\n速度需要用户点击按钮进行选择，所以采用button\n\n### 画运动界面\n\n- 用表格显示格子，作为刻度(十行十列），每个格子的宽为40px，高为40px；\n\n`table>tr*10>th*10`;   快捷方式生成十行十列的表格\n\n​     样式：\n\n​     ①在html的table标签中加入样式：\n\n​      border=\"1\" （表格的边框长度为1px) cellpadding=\"0\"(表格的内边距为0px)  　　　　　　    　　　　　　　　cellspacing=\"0\"这个别忘了设定，因为我这里默认是2px，就导致对不齐\n\n​      ②在css中给每一个td都设置长和宽为38px(因为border四边还有1px占用\n\n​      ③position：absolute 使表格浮动起来，不占用空间，以便div重叠上去\n\n##### 用一个大div设置实际运动场所\n\n用一个大的div来供JS插入新的div(主战场)\n\n样式：\n\n①宽高：均为400px\n\n②背景颜色也是在div上设置，不是在表格上设置\n\n## ②封装产生div的方法\n\n通过在大的div后面附加子div的方式，来显示蛇头，蛇身子和食物。\n\n封装一个函数还创建小div\n\n```js\n var map=document.getElementById(\"map\");\n        function creatDiv(color){\n            var div = document.createElement(\"div\");\n            map.appendChild(div);\n        }\n```\n\n\n\n给小div设置大小\n\n```js\n  function creatDiv(color){\n            var div = document.createElement(\"div\");\n            div.style.width=\"38px\";\n            div.style.height=\"38px\";\n            map.appendChild(div);\n        }\n```\n\n给小div根据传入参数的不同而设置颜色的不同\n\n```js\n  var map=document.getElementById(\"map\");\n        function creatDiv(color){\n            var div = document.createElement(\"div\");\n            div.style.width=\"40px\";\n            div.style.height=\"40px\";\n            div.style.backgroundColor=color;\n            map.appendChild(div);\n        }\n        creatDiv(\"red\"); //创建一个蛇头\n        creatDiv(\"red\"); //创建一个食物\n```\n\n当创建好蛇头和食物后，要让他们的位置也变成absolute。目的是要让他们浮动起来，并且如果生成在同一行的时候，一个不会把另一个挤下去\n\n```js\ndiv.style.position=\"absolute\";\n```\n\n## ③利用随机数产生蛇头和食物div\n\n`Math.random();`随机产生一个[0,1)的随机数\n\n我们的要求：div的left和top应该位于[0,360]之间，并且必须是40的倍数\n\n方法：\n\nMath.random()*10 =>产生一个[0,10）的随机数，即[0,9]的随机数。\n\nparseInt(Math.random()*10) =>将其转化为[0,9]的整数\n\nparseInt(Math.random()*10) *40 =>产生一个[0,360]，且为40的倍数的整数\n\n```js\n       div.style.left = parseInt(Math.random() * 10) * 40 + \"px\";\n            div.style.top = parseInt(Math.random() * 10) * 40 + \"px\";\n```\n\n## ④利用返回值得到通过函数创建的div\n\n因为之后要获取蛇头和食物的位置，但因是在函数中创建的，所以函数已结束就临时变量销毁了，无法获取，所以通过设置函数的返回值为div，并var一个div承接，来得到蛇头和食物\n\n```js\n function creatDiv(color) {\n            XXXXX\n            return div;\n        }\n        var headNode = creatDiv(\"red\");\n        var foodNode = creatDiv(\"blue\");\n```\n\n## ⑤利用定时器让蛇头移动起来\n\n给headNode一个value属性,规定他的移动方向(默认初始为向上移动)\n\n```js\nheadNode.value=\"up\";\n```\n\n利用定时器函数，让蛇头移动(move是个移动的函数)\n\n```js\nvar t = setInterval(move, 1000);\n```\n\n定义move函数(注意这里的变换坐标形式)\n\n```js\n function move() {\n            switch (headNode.value) {\n                case \"up\":\n                    headNode.style.top = parseInt(headNode.style.top) - 40 + \"px\";\n                    break;\n                case \"down\":\n                    headNode.style.top = parseInt(headNode.style.top) + 40 + \"px\";\n                    break;\n                case \"right\":\n                    headNode.style.left = parseInt(headNode.style.left) + 40 + \"px\";\n                    break;\n                case \"left\":\n                    headNode.style.left = parseInt(headNode.style.left) - 40 + \"px\";\n                    break;\n            }\n        }\n```\n\n## ⑥通过键盘的按键来改变蛇头的移动方向\n\n- 利用键盘按下事件： document.onkeydown()。利用上下左右键来更改蛇头的移动方向\n\n- 通过获取键盘的键值，对应不同的方向，那应该怎么获取呢？\n\n  在本例的事件编程中，由`document.onkeydown`可得：事件源是我的键盘，事件就是键盘按下。`function（）{ }`是事件处理函数。在事件处理函数当中其实存在一个默认的参数event（可写可不写，用的时候需要写），表示事件对象，所以获取键盘的键值，就可以通过event.keyCode来获取\n\n  ```js\n  document.onkeydown=function(event){\n   event=event||window.event;\n  }\n  ```\n\n- 监听键值，并根据键盘上敲击的键更改蛇头的移动方向\n\n  并且，在蛇有身体之后，不能让蛇头在向一个方向移动的时候向相对方向移动（自噬）。\n  \n  ```js\n  document.onkeydown = function (event) {\n              event = event || window.event;\n              switch (event.keyCode) {\n                  case 37:\n                      if(headNode.value!=\"right\"||arr.length==0)\n                      headNode.value = \"left\";\n                      break;\n                  case 38:\n                      if(headNode.value!=\"down\" || arr.length == 0)\n                      headNode.value = \"up\";\n                      break;\n                  case 39:\n                      if(headNode.value!=\"left\" || arr.length == 0)\n                      headNode.value = \"right\";\n                      break;\n                  case 40:\n                      if(headNode.value!=\"up\" || arr.length == 0)\n                      headNode.value = \"down\";\n                      break;\n  \n              }\n          }\n  ```\n\n## ⑦检测是否吃到食物并改变食物位置\n\n- 首先需要思考把监测步骤放到哪里？\n\n  应该放到move函数里，每移动一次就判断时候吃到食物\n\n- 如何判断呢？\n\n  当蛇头的top等于食物的top，蛇头的left等于食物的left时，就相等于吃到了食物\n\n- 如果吃到食物后该怎么更新食物的位置呢？\n\n  我本来想的是利用原来createDiv函数重新生成一个div，但是这样不仅执行的代码量多，而且还需要删除原来的食物div，所以正确方法应该是重新刷新食物的top和left值即可\n\n  ```js\n  function move() {\n              switch (headNode.value) {\n                 xxxx...\n              }\n              if(foodNode.style.top==headNode.style.top&& foodNode.style.left == headNode.style.left){\n                  foodNode.style.top ==  parseInt(Math.random() * 10) * 40 + \"px\";\n                  foodNode.style.left == parseInt(Math.random() * 10) * 40 + \"px\";\n              }\n          }\n  ```\n\n## ⑧产生新的身体\n\n1. 通过什么产生新的身体？ createNode函数\n\n   ```js\n   var newNode=createNode(\"yellow\");\n   ```\n\n2. 将新身体跟在什么的后面？ 跟在最后一节的后面。\n\n   所以🐍的身体应该用数组保存。\n\n   在全局中：` var arr=[];//保存身体的数组`\n\n   还要分情况讨论：\n\n   如果只有一个蛇头，最后一节就是蛇头\n\n   如果蛇头后面还有身体，即length>0,通过arr[length-1]来获取蛇的最后一节\n\n   ```js\n   //吃到了食物\n        if (foodNode.style.top == headNode.style.top && foodNode.style.left == headNode.style.left) {\n                   foodNode.style.top = parseInt(Math.random() * 10) * 40 + \"px\";\n                   foodNode.style.left = parseInt(Math.random() * 10) * 40 + \"px\";\n               var newNode=creatDiv(\"yellow\");\n               var lastNode;\n                   //得到最后一节\n                   if(arr.length>0){\n                       lastNode=arr[length-1];\n                   }\n                   else{\n                       lastNode=headNode;\n                   }\n               }\n   ```\n\n3. 给新的一节设置value（移动方向）\n\n   新的一节的移动方向应该和lastNode的移动方向相同\n\n   ```\n   newNode.value=lastNo\n   ```\n\n   \n\n4. 将新身体也附在身体数组中\n\n   ```js\n               arr.push(newNode);\n   ```\n\n## ⑨根据最后一块的运动方向确定新产生一节的位置\n\n1. 如何确定新产生的一节的位置？  需要找到最后一节的移动方向，如果向右，新的一节在它左侧出现，如果向左，新的一节在他右侧出现\n\n2. 如何找到最后一节的移动方向？ 找到最后一节的value\n\n   如果最后一节向右，那么如何让新的一节在最后一节的左侧出现？ 让newNode的left = lastNode的left + 40px, 新一节的top和最后一节的top相同。其他方向同理。\n\n\n## ⑩身体的移动\n\n- 身体移动写在哪？\n\n  身体移动也是移动的一部分，所以应该写在move函数中\n\n- 是先让蛇头移动还是先让身体移动？\n\n  先让身体移动\n\n- 每一节应该是先移动身体再调整方向，还是想调整方向再移动身体？\n\n  因为每一节身体应该与他**上一节上一次**的运动方向相同。所以应该是先移动身体（本次移动的时候的方向还是和上一节上一次移动方向保持一致），在调整方向。\n\n- 要移动每一节，应该用for循环遍历身体arr数组，那遍历时是从第一节开始还是从最后一节开始？\n\n  如果从第一节开始，那么会出现：第一节的运动方向=头，第二节的运动方向=第一节=头，即所有的节的运动方向都等于头的运动方向，所以不对。应该是从最后一节开始遍历。\n\n所以，整个蛇的移动应该是从最后一节开始，不断向前的。\n\n```js\nfunction move() {\n            //遍历整个蛇身子，从最后一节开始\n            for(var i=arr.length-1;i>=0;i--){\n                //蛇的一节移动\n                switch (arr[i].value) {\n                    case \"up\":\n                        arr[i].style.top = parseInt(arr[i].style.top) - 40 + \"px\";\n                        break;\n                    case \"down\":\n                        arr[i].style.top = parseInt(arr[i].style.top) + 40 + \"px\";\n                        break;\n                    case \"right\":\n                        arr[i].style.left = parseInt(arr[i].style.left) + 40 + \"px\";\n                        break;\n                    case \"left\":\n                        arr[i].style.left = parseInt(arr[i].style.left) - 40 + \"px\";\n                        break;\n                }\n                //蛇的一节调整方向,方向与蛇的上一节的上一次的移动方向一致\n                if(i==0){\n                    arr[i].value=headNode.value;\n                }\n                else{\n                    arr[i].value=arr[i-1].value;\n                }\n            }\n            \n            //蛇头移动\n            switch (headNode.value) {\n               xxxx....\n            }\n            \n            //移动过程中吃到了食物\n            if (foodNode.style.top == headNode.style.top && foodNode.style.left == headNode.style.left) {\n                var newNode=creatDiv(\"yellow\"); //身体增加一节\n                var lastNode;\n                //得到最后一节 \n                //给新节点的移动方向赋值\n                newNode.value = lastNode.value;\n                //通过原来最后一个节点的方向更改新节点的位置\n                //将新的一节附在身体数组\n                //更新食物位置     \n            }\n        }\n```\n\n## ⑾判断蛇死亡\n\n情况1：超出边界，撞墙死\n\n情况2：碰到自己的身体，即for循环判断每一块身体是否和头重合\n\n```js\n if (parseInt(headNode.style.top) < 0 || parseInt(headNode.style.left) < 0 || parseInt(headNode.style.top) > 360 || parseInt(headNode.style.left) > 360) {\n                clearInterval(t);\n                alert(\"蛇撞墙了，游戏结束\");\n            }\n            //碰到自己身体死了\n            if (arr.length > 0) {\n                for (var i = 0; i < arr.length; i++) {\n                    if (arr[i].style.top == headNode.style.top && arr[i].style.left == headNode.style.left) {\n                        clearInterval(t);\n                        alert(\"蛇碰到自己身体了，游戏结束\");\n                    }\n                }\n            }\n```\n\n## ⑿更新食物位置的时候防止其在身体部位生成\n\n```js\n //更新食物位置\n                px= parseInt(Math.random() * 10) * 40 + \"px\";\n                py= parseInt(Math.random() * 10) * 40 + \"px\";\n               //遍历整个身子\n                for(var i=0;i<arr.length;i++){\n                    //如果身子的某一节和食物\n                    if(parseInt(arr[i].left)==px&&parseInt(arr[i].top)==py){\n                        //重新生成蛇的位置\n                        px = parseInt(Math.random() * 10) * 40 + \"px\";\n                        py = parseInt(Math.random() * 10) * 40 + \"px\";\n                        //重置i重新从头判断\n                        i=-1;\n                    }\n                }\n                foodNode.style.left =px+\"px\";\n                foodNode.style.top=py+\"px\";\n```\n\n## 吃到食物后增加分数\n\nhtml中：\n\n```html\n<span>\n        <h1 id=\"Score\">score:</h1>\n</span>\n```\n\n设置全局变量：\n\n```js\n        var score = 0;//计分\n        var span = document.getElementById(\"Score\");\n```\n\n吃到食物后：\n\n```js\nscore += 10;\n                span.innerHTML = \"<h1>Score:\" + score + \"</h1>\";\n```\n\n## 点击按钮控制速度\n\njs中以点击按钮事件传入参数进行控制速度：\n\n```js\n/将不变的速度改成传参可以控制的速度，绑定按钮进行传参\n原来：\n var t = setInterval(move, 500);\n现在：\n function changeTime(speed){\n            var t = setInterval(move, speed);\n        }\n```\n\nhtml中：\n\n```\n<button onclick=\"changeTime('200')\">快</button>\n    <button onclick=\"changeTime('300')\">中</button>\n    <button onclick=\"changeTime('500')\">慢</button>\n```\n\n"},{"title":"JS学习笔记","url":"/2022/03/05/JS学习笔记（自用）/","content":"\n小白自学的时候做的笔记，以供之后回来查阅，估计会有很多表述不准确甚至出错的地方，随着学习的加深会慢慢修正补充知识的。\n\n​                                                     ——2022.03.05\n\n## 事件\n\n事件，就是发生的事情，比如点击某个元素，将鼠标移动到某个元素的上方，按下键盘上的某个键\n\n### 拖拽box元素\n\n需要进行三个步骤（其实就是对应了三个事件）\n\n1. 当鼠标在被拖拽元素上按下（不是点一下）时，开始拖拽 ：onmousedown\n2. 当鼠标移动时，被拖拽元素随鼠标移动 : onmousemove\n3. 当鼠标松开时，被拖拽元素固定在当前位置: onmouseup\n\n```\n//拖谁给谁绑定响应函数，本题拖拽的时box1，所以给box1绑定\nvar box1 \n```\n\n\n\n## JS的常用书写方式\n\n1. ### 内嵌式   \n\n   - 在HTML的`<body>`标签中放入`<script type=\"text/javascipt\"> </script>`标签对中，并在`<script>`标签对里书写代码\n\n   - 如果要将JS代码写在`<head>`中，就需要用window.onload=function(){  }包裹起来\n\n2. ### 外链式\n\n   在HTML的`<body>`标签中放入`<script src=\"相对路径\"></script>`\n\n## JS输出语句\n\n1. 弹窗输出 `alert();` 弹窗处alert中的内容\n2. 弹窗确认 `confirm(); ` 弹窗出confirm中的内容，弹窗上有“确认”和“取消”两个按钮\n3. 网页内容区输出：`document.write()`  直接输出在网页页面上\n4. 控制台输出：`console.log()` 输出在控制台\n\n## JS数据类型\n\n- 基本数据类型（参数赋值的时候，传数值） ：String字符串，Number数值，Brglnt大型数值，Boolean布尔值，Null空值，Undefined 未定义，Symbol\n- 引用数据类型（参数赋值的时候，传地址）：Object对象（只有这一种）\n\n## JS的字符串拼接\n\nJS中字符串可以拼接，用“+”就可以拼接，\n\n### 拼接语法：\n\n```markdown\n字符串 + 任意数据类型 = 拼接后的新字符串；\n```\n\n### 拼接规则：\n\n拼接前，会把与字符串相加的数据类型转化为字符串，然后再拼接成一个新的字符串。\n\n### 代码举例：\n\n```js\n\t\t\t\t\t\t\t\t\t\t\t   输出结果\nvar str1 = \"长安\"+\"归故里\";  //字符串+字符串类型    长安归故里\nvar str2 = \"长安\"+666;  //字符串+数值类型          长安666           \nvar str3 = \"长安\"+true; //字符串+布尔类型          长安true\nvar str4 = \"长安\"+null; //字符串+空类型            长安null\nvar obj = {name:'芷若',age:19};\nvar str5 = \"长安\"+obj;  //字符串+object类型     长安[object Object] \n\n```\n\n## 对象\n\n对象是一种复合的数据类型，在对象中可以保存多个不同的数据类型的属性\n\n### 对象的分类\n\n1. 内置对象：\n   由ES标准中定义的对象，比如：Object、Math、Date、Function等。\n\n2. 宿主对象：\n\n   由JS的运行环境（浏览器）提供的对象，比如：BOM，DOM\n\n3. 自定义对象：\n\n   由开发人员自己创建出来的对象\n\n注意：通过new关键字创建出来的对象实例，都是对象类型\n\n### 对象的创建方法\n\n1. 使用**内置**的构造函数创建对象（工厂模式）\n\n   ```js\n   var student = new Object();\n   student.name = \"芷若\";\n   ```\n\n   弊端：使用的构造函数都是Object，所以创建的对象都是Object这个类型，导致无法区分多种不同类型的对象\n\n   \n\n2. 使用对象字面量创建对象\n\n   字面量：为变量赋值时的常数量\n\n   对象字面量：封闭在花括号对{}中的对象的零个或多个“属性名：值”的列表。\n\n   ```js\n   //多个“属性名：值”\n   var student ={\n         name:\"芷若\";\n         age:19;\n   }\n   //零个\n   var student = {};\n   ```\n\n   \n\n3. 利用构造函数创建对象\n\n   ```js\n   //先自己创建一个构造函数\n   function Star(name,age){\n     this.name=name;\n     this.age=age;\n     this.sing=function(){\n      console.log('我会唱歌');\n      }\n   }\n   //再用自建的构造函数创建对象\n   var person1 = new Star(\"双笙\",18);\n   var person2 = new Star(\"林俊杰\",20);\n   person1.sing(); \n   person2.sing();\n   ```\n\n   \n\n### 对象的赋值和修改\n\n- 这是基本数据类型：\n\n```js\nvar name1 = \"长安\";\nvar name2 = name1;\nname2 = \"故里\";\nconsole.log(name1); //输出结果：长安\nconsole.log(name2); //输出结果：故里\n```\n\n- 这是object类型（对象）：\n\n```js\nvar obj1 = new Object();\nobj1.name=\"长安\";\nvar obj2 = obj1;\nobj2.name = \"故里\";\nconsole.log(name1); //输出结果：故里\nconsole.log(name2); //输出结果：故里\n```\n\nobject类型赋值后竟然会改变本体。这里的object就相当于C语言中的一个指针指向的内容，而将obj1赋值给obj2就相当于让obj2也指向了这块内容，所以修改obj2所指向的内容后，自然也就修改了obj1\n\nJS中的对象和C++中的对象相似之处：\n\n1. 作用都是封装信息，比如一个student类中可以封装学生的姓名，年龄。成绩\n\n   \n\n2. C++中的对象有成员函数和成员变量。JS中的对象也是如此，不过叫的是特征（属性）和行为（方法）\n\n#### 获取对象中的属性：\n\n**方式1**：`对象.属性名`\n\n## 基本包装类型\n\n### 三个基本包装类：\n\n- String():将基本数据类型的字符串，转换为String对象\n\n- Number():将基本数据类型的数字，转化为Number对象\n\n- Boolean():将基本数据类型的布尔值，转化为Boolean对象\n\n### 转换方法：\n\n```js\nlet str1 = 'qianguyihao';\nlet str2 = new String('qianguyihao');\n\nlet num = new Number(3);\n\nlet bool = new Boolean(true);\n```\n\nstr2，num, bool的类型都是object\n\n将基本数据类型转化为对象后，就可以绑定属性和方法了\n\n### String()对象常用方法\n\n1. indexOf()/lastIndexOf():获取字符串中指定内容（字符或字符串）的索引\n\n   - 语法一：\n\n     ```js\n     索引值 = str.indexOf(查询的字符或者字符串)\n     ```\n\n     indexOf() 是从前向后查找，lastIndexOf()是从后向前查找，如果找到了，返回第一次出现的索引，如果没有找到，返回-1\n\n   - 语法二：\n\n     ```\n     索引值 = str.indexOf(查询的字符串，起始的下标位置)\n     ```\n\n2. charAt(index)获取指定位置的字符\n\n   str.charAt(index)和str[index]等价\n\n### Number()对象常用方法\n\n1. Number.isInteger()判断是否为整数\n\n   语法：`布尔值 = Number。isInteger(数字);`\n\n2. toFixed()小数点后面保留几位\n\n   语法：`字符串 = myNum.toFixed(num);`\n\n   解释：将对象myNum的小数点后面保留num位小数（四舍五入），不会改变原数字，返回的是字符串\n\n### Math()对象的方法\n\n**注意：调用Math对象的方法时，不需要创建对象，即不需要通过new来调用，直接使用即可**\n\n```js\nvar num = -0.6;\n\n console.log(Math.abs(num));        //取绝对值\n\n console.log(Math.floor(num));      //向下取整，向小取\n\n console.log(Math.ceil(num));       //向上取整，向大取\n\n  console.log(Math.round(num));      //四舍五入取整（正数四舍五入，负数五舍六入）\n\n console.log(Math.random());        //生成0-1之间的随机数\n```\n\n## 数组\n\n数组中可以存放**任意对象**的数据，比如：字符串，数字，布尔值，甚至是对象\n\n### 创建数组对象\n\n1. 和C语言一样的创建方法\n\n   ```js\n   var arr1 = []; //创建一个空的数组\n   var arr2 = [1,2,3]; //创建并初始化数组\n   ```\n\n2. 特有：用构造函数创建数组\n\n   ```js\n   let arr = =new Arrat(参数);\n   ```\n\n   - 如果参数为空，则表示创建一个空数组，如果参数是一个数值，表示创建的数组的长度，如果有多个参数，表示数组中的元素\n\n   - 举例：\n\n     ```js\n     var arr2 = new Array(); // 参数为空\n     var arr3 = new Array(4); // 参数为一个数值\n     var arr4 = new Array(15, 16, 17); // 参数为多个数值\n     ```\n\n     打印结果：\n\n     ```js\n     arr2 = [];\n     arr3 = [null, null, null, null];\n     arr4 = [15, 16, 17];\n     ```\n\n   \n\n## 函数\n\n- 函数也是一个对象\n- 使用typeof 检查一个函数对象时，会返回一个function\n\n### 函数的定义\n\n1. 利用函数关键字自定义函数\n\n   ```js\n   function 函数明(形参1，形参2...形参n){\n       语句;\n   }\n   ```\n\n   举例：\n\n   ```js\n   function fun1(a, b){\n   \treturn a+b;\n   }\n   ```\n\n2. 利用函数表达式（匿名函数）\n\n   ```js\n   var 变量名 = function(形参1，形参2,...形参n){\n        语句;\n   }; //注意这里有个分号，表示赋值语句结束\n   ```\n\n   举例：\n\n   ```js\n   var fun2 = function() {\n   \tconsole.log(\"我是匿名函数中的代码\");\n   };\n   \n   //这里调用的时候有两种等价的写法\n   var v = new Vehicle();\n   var v = new Vehicle; //不推荐这样写\n   ```\n   \n   **注意：**\n   \n   - fun2是变量名，不是函数名\n   - 函数表达式实际就是将匿名函数赋值给一个变量\n\n### 函数的调用\n\n1. 普通函数的调用\n\n   ```js\n   函数名();\n   ```\n\n   或者\n\n   ```\n   函数名.call();\n   ```\n\n   举例：\n\n   ```js\n   function fn1() {\n   \tconsole.log('我是函数体里面的内容1');\n   }\n   \n   function fn2() {\n   \tconsole.log('我是函数体里面的内容2');\n   }\n   \n   fn1(); // 调用函数\n   \n   fn2.call(); // 调用函数\n   \n   ```\n\n2. 通过对象的方式调用\n\n   ```js\n   //定义一个类\n   var obj = {\n     name: \"圣米歇尔山\", //注意这里是逗号\n     draw: function{\n        console.log(\"圣米歇尔山在哪里捏？\");\n     }\n   };\n   //调用对象的函数\n   obj.draw();\n   ```\n\n3. 立即执行函数\n\n   ```js\n   (function(){\n        console.log('为什么立即执行函数这么多括号？！！');\n   })();\n   ```\n   \n   举例：\n   \n   ```js\n   \t(function(a, b) {\n   \t\tconsole.log(\"a = \" + a);\n   \t\tconsole.log(\"b = \" + b);\n   \t})(123, 456);\n   ```\n   \n   注意：立即执行函数在定义之后就会自动调用，这种函数通常只执行一次，因为没有变量保存它，执行完就找不到了（昙花一现）\n   \n4. 用构造函数来调用\n\n   ```js\n   function Person(name, gender, hobby) {\n       this.name = name;\n       this.gender = gender;\n       this.hobby = hobby;\n       this.age = 6;\n   }\n   \n   var p1 = new Person('zs', '男', 'basketball');\n   var p2 = new Person('ls', '女', 'dancing');\n   ```\n\n   构造函数：专门来生成对象的函数，它提供模板，描述对象的基本结构，一个构造函数可以通过new来生成多个对象，这些对象都有相同的结构。\n\n5. 绑定事件函数\n\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\">\n       <head>\n           <meta charset=\"UTF-8\" />\n           <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n           <title>Document</title>\n       </head>\n       <body>\n           <div id=\"btn\">我是按钮</div>\n   \n           <script>\n               var btn = document.getElementById('btn');\n               //2.绑定事件\n               btn.onclick = function() {\n                   console.log('点击按钮后，弹出了我');\n               };\n           </script>\n       </body>\n   </html>\n   ```\n\n   给点击这个操作绑定了事件（弹窗）\n\n### 函数的传参\n\nJS允许传入任意个参数而不影响调用，因此，传入的参数比定义的参数多没有问题（即使函数内部不需要这些参数），传入的参数比定义的少也没有问题。\n\n```js\nabs(19,'nalabala'); //返回19\nabs(-9,'haha','hehe',null); //返回9\nabs();  //返回NaN\n```\n\n\n\n### 调用函数和获取函数的区别\n\n获取方法与调用方法\n\nC语言中只能调用方法，不能获取方法，而JS可以，如下例：\n\n```js\n    var obj = new Object();\n    obj.sayName = function () {\n        console.log('smyhvae');\n    };\n\n    console.log(obj.sayName);  //没加括号，就是获取方法\n    console.log(obj.sayName());  //加了括号，就是调用方法。即：执行函数内容，并执行函数体的内容\n\n```\n\n` console.log(obj.sayName);`执行结果：  \n\n```js\nƒ () {\n console.log('smyhvae');     //直接把方法整s\n                }\n```\n\n`console.log(obj.sayName()); `执行结果：\n\n```js\nsmyhvae //首先调用函数，执行函数内容\nundefined   //又因为该方法没有返回值，所以输出undefined\n```\n\n总结：\n\n- `fun()`：调用函数。调用之后，还获取了函数的返回值\n- `fun`：获取函数。相当于直接获取了整个函数对象\n\n### 构造函数\n\n**构造函数**主要用来初始化对象，即为对象成员赋初值，总是与new一起使用，在ES6之前由于没有**类**的概念，所以常把对象的一些公共属性和方法抽取出来。然后封装到构造函数中。\n\n#### 构造函数和普通函数\n\n1. 构造函数的创建方法和普通函数没有区别，都是`function 函数名(){  }`，不同的是构造函数习惯首字母大写\n2. 两者的调用方式不同。普通函数直接调用，而构造函数需要用new关键字来调用\n3. 二者this的指向不同。普通函数调用时，如果普通调用，this指向的是window，如果以方法的形式调用，this是调用方法的那个对象。 当以构造函数的形式调用时，this是新创建的实例化对象\n4. 返回值：普通函数可以有返回值，也可以没有返回值，但是构造函数没有返回值（不用写return），“new一个构造函数的流程” 会解释为什么不需要返回值\n\n#### 书写规范：\n\n1. 使用构造函数创建某一类对象的时候，**首字母要大写**（与普通函数区别开）\n\n1. 构造函数内部使用了**this**关键字，代表了要生成的对象实例\n\n2. 构造函数生成对象的时候，必须要用new指令\n\n   举例：\n   \n   ```js\n   //先自己创建一个构造函数\n   function Star(name,age){\n     this.name=name;\n     this.age=age;\n     this.sing=function(){\n      console.log('我会唱歌');\n      }\n   }\n   //再用自建的构造函数创建对象\n   var person1 = new Star(\"双笙\",18);\n   var person2 = new Star(\"林俊杰\",20);\n   person1.sing(); \n   person2.sing();\n   ```\n\n#### New一个构造函数的流程\n\n1. 开辟内存空间，在内存中创建新的空对象\n2. 让this指向这个新的空对象\n3. 执行构造函数里的代码，为这个新对象添加属性和方法\n4. 返回这个新对象（所以构造函数里面不需要return）\n\n#### 实例成员和动态成员\n\n**成员**:成员包括构造函数中的属性和方法\n\nJS的构造函数中可以添加一些成员。添加方法有两种：①在构造函数本身上添加②在构造函数内部的this上添加\n\n**实例成员**：构造函数中用this添加的成员，实例成员只能通过实例化对象来访问。\n\n```js\n//用this来添加实例成员，下面的name,age,sing都是实例成员\nfunction Star(name,age){\n  this.name=name;\n  this.age=age;\n  this.sing=function(){\n   console.log('我会唱歌');\n   }\n}\n//实例成员只能通过实例化对象访问\n//正确访问方法：\nvar person1 = new Star(\"双笙\",18);\nperson1.sing(); \n//错误访问方法（不可以通过构造函数来访问实例成员）\nStar.sing();\n```\n\n**静态成员**：在构造函数本身上面添加的成员，只能通过构造函数来访问\n\n```js\nfunction Star(name,age){\n   this.name=name;\n   this.age=age;\n}\nvar person1 = new Star(\"双笙\",18);\n\n//在构造函数本身上面添加成员\nStar.sex = \"女\";\n//正确访问方法：\nconsole.log(Star.sex);\n//错误访问方法：\nconsole.log(person1.sex);\n```\n\n### 高阶函数\n\n概念：一个函数A作为另一个函数B的： 1.参数 2.返回值时，我们称函数B为高阶函数。简单来说，高阶函数是 **对其他函数进行操作** 的函数\n\n**类型1**：把其他函数作为参数（这个例子我现在还不太理解）\n\n```js\nfunction fn1(a, b, callback) {\n    console.log(a + b);\n    callback && callback();\n}\n\nfn1(10, 20, function () {\n    console.log('我是最后执行的函数');\n});\n\n```\n\n试着理解一下吧：\n\n1. `callback && callback();`\n\n- callback是回调的意思（call back,回我电话），指当执行栈中的同步任务执行完毕后再执行回调的内容\n\n- callback也可以作为函数A的形参，所对应的实参一般是另一个函数B。即执行完了函数A的所有同步任务之后，会执行函数B\n- callback && callback();要理解这句话，首先要理解&&逻辑与，先执行左边，如果左边为真，就会执行右边，如果左边为假，就不执行右边。所以A&&B就等价为`if(A) {  B }` ，因此`callback&&callback.call()` 就是 `if(callback) callback.call()`，即如果调用的时候传入了callback所对应的实参，就执行回调函数这个操作，如果没有传入所对应的参数（JS中函数的参数可以缺省），就不执行回调函数这个操作。\n\n2.  \n\n```js\nfn1(10, 20, function () {\n    console.log('我是最后执行的函数');\n});\n```\n\n   虽然很优雅的写法，但我第一眼没看出来这是干啥的.....，写成下面这个形式好理解一些\n`fn1(10, 20,   function () {console.log('我是最后执行的函数');}  );`\n   这其实是fn1函数的调用，第三个参数是一个函数，它是作为callback的实参传过去的。\n\n3. 执行步骤\n\n   调用函数，先执行 fn1中的内容：`console.log(a + b);`，执行完毕后执行回调函数中的内容： `console.log('我是最后执行的函数');`\n\n**类型二**：把函数作为返回值（常结合闭包）\n\n```js\nfunction fn1() {\n    let a = 20;\n\n    return function () { //将函数作为返回值返回\n        console.log(a);\n    };\n}\nconst foo = fn1(); // 执行 fn1() 之后，会得到一个返回值。这个返回值是函数\nfoo();\n```\n\n\n\n## 作用域：\n\n### 分类：\n\n全局作用域和局部作用域\n\n### 访问关系：\n\n- 内部作用域可以访问到外部作用域的变量，但在外部作用域无法访问到内部作用域的变量\n- 如果局部作用域和全局作用域的变量重名的话，在局部修改局部作用域的变量的值并不会改变全局作用域的变量的值。\n- JS的函数在查找变量时从自身函数定义开始，由”内“向”外“查找。如果内部函数定义了域外部函数重名的变量。则内部函数的变量将”屏蔽“外部函数的变量\n\n## 闭包\n\n**概念**：指有权访问另一个函数作用域中变量的**函数**。 (closure)\n\n由上面的定义我们知道，闭包是一种函数，如果A函数访问到了B函数内的变量，那么称函数B为闭包函数\n\n### 常规情况下：\n\n- 函数内部可以访问全局变量和局部变量\n- 函数外部只能访问全局变量，不能访问局部变量\n- 当函数执行完毕后，本作用域内的局部变量会被销毁\n\n比如下面这样的代码：\n\n```js\n//定义函数\nfunction foo(){\n     let a = 1;\n}\n//调用函数\nfoo();\nconsole.log(a);//打印报错：Uncaught ReferenceError: a is not defined\n```\n\n原因：a是函数内的局部变量，外部无法访问。当调用完foo函数之后，a变量已经被销毁了，所以a无法访问。\n\n### 闭包函数中：\n\n我靠，从这个例子我才发现原来JS中函数可以嵌套定义？！！\n\n```js\nfunction fn1(){\n   let a = 10;\n    //在\n   function fn2(){\n       console.log(a);\n    }\n   fn2();\n}\nfn1();\n```\n\n 上面这个例子也可以这么写：\n\n```js\nfunction(){\n     let a = 20;\n     \n     return function(){\n        console.log(a);\n     };\n}\nvar foo = fn1();  //fn1的返回值是一个函数\nfoo(); //调用foo\n```\n\n 输出结果：10\n\n- 函数fn2只能在fn1中调用，如果在fn1外面调用，将会报错\n- 如果嵌套的内层函数使用了外层函数的变量或参数，即fn2中使用了fn1中的变量a，这个嵌套函数就形成了一个闭包，将fn1成为闭包函数\n- 闭包能在它fn1执行完之后仍然能够访问fn1里的变量和参数\n\n### 闭包的作用\n\n在上面那个例子中，本来fn1执行完毕后，它里面的变量a会立即销毁，但此时由于产生了闭包，fn1中的变量不会立即销毁，因为fn2函数还要继续调用变量a。\n\n并且，在全局中通过foo()承接fn1的返回值,达到了在全局作用域中也可以访问局部作用域中的变量a\n\n可见，**闭包延伸了变量的作用范围**\n\n## this\n\n解析器在调用函数时每次都会像函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象\n\n这个对象我们称为函数执行的上下文对象\n\n根据函数**调用**方式的不同，this会指向不同的对象\n\n以函数形式调用，this的对象是window。\n\n```js\nfunction func1(){\n   console.log(\"this.window\");\n}\nfunc1();//直接调用函数，this指向window全局\n等价于：window.fun1();\n输出结果：object Window\n\n```\n\n以对象的方式调用，this指向调用方法的对象\n\n```js\n \n //把obj的一个属性设置成了函数func1\n var obj = {\n   sayname:func1\n};\nobj.sayname();//以方法的形式调用函数\n\n输出结果：object Object\n```\n\n总结：\n\n1. **普通函数，立即执行函数**调用时，this的指向时window（全局）\n2. **以方法的形式**调用时，this指向调用方法的那个对象\n3. 以**构造函数**的形式调用时，this指向new出来的对象\n4. 以**事件绑定函数**的形式调用时，this指向绑定事件的对象\n5. 用**call和apply**调用时，this指向指定的（括号里面的第一个参数）那个对象\n\n## 同步和异步\n\n### JS是单线程\n\n即同一个时间只能做一件事，比如某个DOM元素进行添加和删除的操作时，不能同时进行，应该先添加，之后再删除。\n\n单线程意味着，所有任务都需要排队，即前一个任务结束，才会执行后一个任务，这样导致的问题是：JS执行的时间过长，页面渲染加载会有阻塞\n\n### 回调函数\n\n知乎上一篇文章讲的很好，附上链接：\n\n[10张图理解回调函数](https://zhuanlan.zhihu.com/p/326902537)\n\n### 同步\n\n前一个任务结束后再执行后一个任务，程序的执行顺序和任务的排列顺序是一致的。比如做饭的同步做法：烧水煮饭（10分钟之后），再去切菜，炒菜。\n\n### 异步\n\n在做这件事情同时，还可以去处理其他事情。比如做饭的异步做法：在烧水的同时，利用这10分钟，去切菜，炒菜。\n\n比如下列代码：\n\n```js\nconsole.log(1);\nsetTimeout(function(){\n   console.log(3);\n},2000);\nconsole.log(2);\n```\n\n输出结果：1   2   3\n\n因为 等待函数要等待2秒钟才执行，所以会先执行console.log(2);\n\n可是如果把时间换成0，即：\n\n```js\nconsole.log(1);\nsetTimeout(function(){\n   console.log(3);\n},0);\nconsole.log(2);\n```\n\n输出结果依旧是： 1 2 3，为了解决这个问题，我们需要了解\n\n### JS的执行机制\n\n1. 先执行执行栈中的同步任务\n2. 如果遇到异步任务，将其放入任务队列中，先不执行\n3. 当执行栈中的所有同步任务执行完毕后，系统会根据次序读取任务队列中的异步任务，依次执行\n\n### 同步任务：\n\n同步任务都在主线程上执行，形成一个执行线\n\n### 异步任务：\n\n异步任务是指不进入主线程，而进入“任务队列”，只有主线程任务执行完毕后，“任务队列”才开始通知主线程请求执行任务，该任务才会进入主线程执行。\n\n异步任务是通过回调函数实现的。有以下三个种类：\n\n1. 普通事件，如onclick,resize等\n2. 资源加载，如load，error等\n3. 定时器，如setInterval,setTimeout等\n\n\n\n## JS和C语言的不同之处：\n\n1. JS中声明变量用的是let或者var,它是一种弱类型语言（动态语言），不用声明变量的类型，并且变量的数据类型是可以变化的，比如：\n\n   ```js\n   var name =\"zhiruo\";\n   name = 123; //这里强制将字符串类型转化为了数值类型\n   ```\n\n   \n\n   并且，JS中变量可以不用声明直接赋值  \n\n   \n\n3. JS中没有字符类型，只有字符串类型，并且字符串既可以用双引号引起来，也可以用单引号引起来\n\n   \n\n4. JS中字符串的长度用的是`str.length;`而C++中字符串的长度用的是`str.length()`\n\n   \n\n5. +号\n\n在C语言中，+号就是加号，而在JS中”+“有可能是加号（数值相加），也有可能是连字符（字符串拼接），类似C++中的运算符重载。要区分清楚以下几种情况：\n\n```js\nconsole.log(\"我\" + \"爱\" + \"你\");\t//连字符，把三个独立的汉字，连接在一起了\nconsole.log(\"我+爱+你\");\t\t\t//原样输出\nconsole.log(1+2+3);\t\t\t\t//输出6\nconsole.log(5+'3');\t\nconsole.log(5-'3');\t\n```\n\n输出：\n\n```\n我爱你\n我+爱+你\n6\n53\n2\n```\n\n总结：\n\n- 如果加号两边都是Number类型，那么就是数字相加，否则，就是连字符相加\n- 如果符号是减号，除号，乘号，取模运算符，计算机会帮忙进行隐式转换，即5-’3‘的运算结果是2\n\n5. JS中的函数可以嵌套定义,c语言不可以\n\n   ```js\n   function fn1() {\n       let a = 10;\n       //fn1中嵌套定义了fn2\n       function fn2() {\n           console.log(a);\n       }\n       //调用fn2\n       fn2();\n   }\n   fn1();\n   ```\n\n   - 函数fn2只能在fn1中调用，如果在fn1外面调用，将会报错\n   - 如果嵌套的内层函数使用了外层函数的变量或参数，即fn2中使用了fn1中的变量a，这个嵌套函数就形成了一个闭包\n   - 闭包能在它fn1执行完之后仍然能够访问fn1里的变量和参数\n   \n6. JS是**基于对象（object-based）的语言**。 但是，它又不是一种真正的面向对象编程语言，因为它的语法中没有C++中的class（类）（在es6以前）。在C++中，“类”就是对象的模板，对象就是“类”的实例。JS不是基于类的，二十基于构造函数和原型链的。\n\n   即：JS使用构造函数来作为对象的模板，构造函数就是专门生成实例对象的函数\n","tags":["笔记"],"categories":["计算机笔记"]},{"title":"离散数学の笔记","url":"/2022/03/02/离散数学の笔记/","content":"\n### 一些英译中\n\ncompound proposition :复合命题\n\nnegation of statements: 陈述句的否定\n\nDe Morgan's laws :德摩根定律\n\ntruth tables：真值表\n\n absorption laws：吸收律\n\ntautology：重言式，永真式\n\nlogical operator：逻辑运算符\n\n\n\n\n\n### 命题\n\n##### 概念：\n\n- 命题，是指具有唯一真值的陈述句\n- 疑问句、祈使句、感叹句，因为无法判断真假，所以都不是命题\n- 真用1或T来表示，假用0或F来表示，因为命题只有这两种真值，所以这种逻辑成为二值逻辑\n\n##### 例题：\n\n- 1+101=110  在二进制下为真，在十进制下为假，真值不唯一，所以不是命题\n- 别的星球上有生物  虽然现在不确定，但是这个问题是有客观答案的 ，并不以你我的意志而转移，所以是命题\n- 全体立正！ 祈使句不是命题\n- 天气多好啊！ 感叹句不是命题\n\n**注意**：一个陈述句暂时不能确定真值，但到了一定时间就可以确定，与一个陈述句的真值不能唯一确定是不一样的\n\n- x>3  　x的取值范围不同，本句话的真假是不一样的，所以不是命题\n- 2190年人类将移居火星   虽然现在无法确定，但是到了2190年就可以唯一确定本句话的真假，所以是命题\n\n##### 分类：\n\n1. 原子命题：一个陈述句再也不能分解成更为简单的语句，则由它构成的命题成为原子命题\n2. 复合命题：由原子命题，命题联结词和圆括号组成\n\n### 命题联结词\n\n1. 否定联结词： ┐\n\n   ┐p和p的真假是相反的\n\n2. 合取联结词：∧\n\n   p∧Q读作“P与Q”或者“P且Q”  \n\n   当且仅当P和Q同为真，命题P∧Q的真值才为真\n\n3. 析取联结词：∨\n\n   P∨Q读作“P或Q”\n\n   只要P、Q中有一个为真，命题P∨Q就为真\n\n4. 条件(蕴含)联结词：→\n\n   P→Q读作P条件Q，或者“若P则Q” “P仅当Q” “P是Q的充分条件”\n\n   只有当P的真值为真而Q的真值为假时，命题P→Q的真值为假，其余都为真\n\n   例子：\n\n   ①只要天下雨，我就回家\n\n   ②只有天下雨，我才回家\n\n   ③除非天下雨，否则我不回家\n\n   ④仅当天下雨，我才回家\n\n   解析：①强调的是如果天下雨了，那我就回家，②③④强调的是如果我回家了，那一定是天下雨了。 所以①可符号化为P→Q ，②③④可符号化为Q→P\n\n5. 双条件联结词：↔\n\n   P↔Q读作“P当且仅当Q”，只有两者同时为真或同时为假时，P↔Q才为真\n   \n6. 异或（双条件非）联结词：⊕\n\n   当且仅当P和Q的真值不相同时，P⊕Q为T\n\n7. 与非联结词：↑\n\n   P↑Q读作“P合取非Q” 或者“P与非Q”，当且仅当P和Q均为T时，P↑Q为F，否则P↑Q为T。\n\n8. 或非联结词：↓\n\n   P↓Q读作“P析取非Q”或者“P或非Q”，当且仅当P和Q均为F时，P↓Q为T，否则P↓Q为F\n\n### 命题公式\n\n命题公式由原子命题，命题联结词，圆括号构成，但是并不是由这三类符号组成的的任何符号串都能成为命题公式 ，合理的命题公式叫做合式公式\n\n##### 定义\n\n合式公式是由下列规则生成的公式：\n\n1. 单个原子公式是合式公式\n2. 若A是一个合式公式，那么（ ┐A）也是一个合式公式\n3. 若A、B是合式公式，则（A^B）、（A∨B）、（A→B）和（A↔B）都是合式公式\n4. 只有有限次的使用1，2和3生成的公式才是合式公式\n\n##### 约定：\n\n1. 联结词的优先级从高到低是： ┐、∧、∨、→、↔\n\n2. 相同的联结词按从左到右的次序计算时，圆括号可以省略\n3. 最外层的圆括号也可以省略\n\n### 命题的翻译和符号化\n\n##### 将自然语言符号化\n\n1. 小王边走边唱\n\n   P：小王走路  Q：小王唱歌  \n\n   => P^Q \n\n2. 如果今天不下雨并且不刮风，我就去书店\n\n   P：今天下雨（不能设位今天不下雨，因为“今天不下雨”不是原子命题）\n\n   Q：今天刮风\n\n   R：我去书店 \n\n   =>（┐P∧ ┐Q）→R\n\n3. 小刚要么在学习，要么在玩游戏\n\n   P：小刚在学习\n\n   Q：小刚在玩游戏\n\n   => (P∧ ┐Q)∨(┐P∧ Q)  \n\n   即：小刚在学习且没有玩游戏，或者小刚在玩游戏且没有学习\n\n4. 除非a能被2整除，否则a不能被4整除\n\n   P：a能被2整除\n\n   Q：a能被4整除\n\n   =>  ┐P →  ┐Q   即：a如果不能被2整除，则a不能被4整除\n\n   或者Q→P   即：如果a能被4整除，那么a一定可以被2整除\n\n5. 如果天不下雨，我们就去打篮球，除非班上有会\n\n   P：天下雨\n\n   Q：我们去打篮球\n\n   R：今天班上有会\n\n   =>（┐P∧ ┐R）→Q   即：我们打篮球的条件必须是天不下雨且班上没有会\n\n   或者：┐R→(┐P→Q）即：如果没有会，并且没有下雨，我们就去打篮球\n   \n6. 离散数学无用且枯燥无味是不对的\n\n   P：离散数学是有用的\n   Q：离散数学是枯燥无味的\n\n   ¬ ( ¬ P ∧ Q ) \n\n7. 如果校长和小王都不去，则小李去\n\n   P：小张去\n   Q：小王去\n   R：小李去\n\n   ( ¬ P ∧ ¬ Q ) → R \n\n8. p，q不能同时取,即只能取一个\n\n   (P∧ ┐Q)∨(┐P∧ Q) \n\n9. 若P去, 则Q不能去\n\n   P →  ┐Q\n\n10. C和D要么都有，要么都没有\n\n   (C∧D)∨(┐C∧ ┐D)\n\n11. 股票P和Q中必然有一种或两种要抛出\n\n    P∨Q\n\n### 真值表\n\n含有n个原子命题的命题公式所对应的真值共有2^n中情况\n\n### 等价\n\n##### 定义\n\n给定两个命题公式，若对于其中任意一组指派而言，A和B的真值都相同，则称A和B是等价的\n\n可以通过等值关系进行化简得到两个式子等值，也可以通过真值表来判断等值\n\n##### 基本等值式\n\n1. ﹁ ( ﹁ G ) = G\n   （双重否定律）\n\n2. G ∧ G = G   G ∨ G = G  **(a*a=a  a+a=a)**\n   （幂等律）\n\n3. G ∨ H = H ∨ G   **a+b=b+a**\n   G ∧ H = H ∧ G  ab=ba\n   （交换律）\n\n4. G ∨ ( H ∨ S ) = ( G ∨ H ) ∨ S  **a+(b+c)=(a+b)+c**\n   G ∧ ( H ∧ S ) = ( G ∧ H ) ∧ S  **a*(b *c)=(a * b)*c**\n   （结合律）\n\n5. G ∨ ( H ∧ S ) = ( G ∨ H ) ∧ ( G ∨ S )   a+bc=(a+b)(a+c)\n   G ∧ ( H ∨ S ) = ( G ∧ H ) ∨ ( G ∧ S )  **a(b+c)=ab+ac**\n   （分配律）\n\n6. ﹁ ( G ∧ H ) = ﹁ G ∨ ﹁ H \n   \n   ﹁ ( G ∨ H ) = ﹁ G ∧ ﹁ H \n   \n    （去掉括号后合取变析取，析取变合取）\n   （德摩根律）\n   \n7. G ∨ ( G ∧ H ) = G  **a+ab=a**\n\n   G ∧ ( G ∨ H ) = G  **a*(a+b)=a**\n   （吸收律）\n\n8. G ∨ 1 = 1\n   G ∧ 0 = 0\n   （零律）\n\n9. G ∧ 1 = G\n\n   G ∨ 0 = G\n\n   （同一律）\n\n10. G ∧﹁ G = 0\n    G V ﹁ G = 1\n    （否定律）\n\n11. G → H = ﹁ G ∨ H\n    （条件转化律）\n\n12. G ↔ H = ( G → H ) ∧ ( H → G ) = ( ﹁ G ∨ H ) ∧ ( ﹁ H ∨ G )\n    （双条件传化律）\n\n13. G → H = ﹁ H → ﹁ G\n    （假言易位）\n\n14. G ↔ H = ﹁ G ↔ ﹁ H\n    （等价否定等式）\n\n##### 等价置换定理\n\n如果X是合式公式A的一部分，且X本身也是一个合式公式，则称X为合式公式A的子公式\n\n设X是合式公式A的子公式，若X=Y。如果将A中用的X用Y来置换，所得到的公式B与公式A等价。即A=B\n\n### 重言式(永真式)与蕴含式(永假式)\n\n##### 定义\n\n对于某个命题公式，如果其在分量的任何指派的指派下的真值均为T，则称该命题公式为**重言式**或**永真式**。\n\n对于某个命题公式，如果其在分量的任何指派的指派下的真值均为F，则称该命题公式为**矛盾式**或**永假式**。\n\n如果某个命题不是矛盾式，则称该命题为**可满足式**\n\n**蕴含式**：当且仅当P→Q是重言式时，我们称“P蕴含Q“，并记作P=>Q\n\n要证明P=>Q,只需证明P→Q,或者证明﹁Q→﹁P\n\n### 范式\n\n范式是析取范式与合取范式的总称。\n\n##### 定义：\n\n- 命题变元或命题变元的否定称为**文字**。 P，﹁P，Q，﹁Q\n- *有限个*文字的析取称为**简单析取式**（或**子句**）。 P(退化的析取式，只有一个文字），﹁P（退化的析取式）， P ∨ ﹁Q（2个文字）\n- *有限个*文字的合取称为**简单合取式**（或**短语**）。 P，﹁P，P ∧ ﹁Q \n- 单个的文字既是简单析取式，也是简单合取式\n- P与﹁P称为**互补对**\n- *有限个*简单合取式（短语）的析取式称为**析取范式**  如  ( G ∧ H ) ∨ ( G ∧ S )，又如 P ∨ ﹁Q ,P ,﹁P。**内部合取，外部析取**\n- *有限个*简单析取式（短语）的合取式称为**合取范式**，如（P∨ H ) ∧ ( ﹁H ∨Q）,又如 P ∧ ﹁Q ,P ,﹁P 。**内部析取，外部合取**\n\n**注意1：p∧q∧r既是析取范式，也是合取范式**。\n\n**原因**：因为这个式子是有限个文字的合取，所以他是合取范式，也是简单合取式。而根据析取范式的定义是有限个简单合取式的析取式，这个有限个可以取1个，即一个简单合取式也是析取式\n\n##### 注意2：\n\n析取范式、合取范式仅含联结词集{﹁，∧，∨}，且否定联结词仅出现在命题变元之前\n\n##### 范式存在定理\n\n对于任意公式，都存在与其等价的析取范式和合取范式，且范式不唯一\n\n##### 转化方法：\n\n1. 将公式中的↔，→ 用联结词﹁，∧，∨来取代（**否定也是联结词**）\n\n   - 蕴含式：G → H = ﹁ G ∨ H\n\n   - 双条件传化律：G ↔ H = ( G → H ) ∧ ( H → G ) \n\n   利用蕴含式再次转化： = ( ﹁ G ∨ H ) ∧ ( ﹁ H ∨ G )\n\n2. 将否定联结词内移(德摩根律)到各个命题变元的前端，并消去否定号（双重否定律）\n\n   - 双重否定律：﹁(﹁ G)=G\n\n   - 德摩根律：﹁ ( G ∧ H ) = ﹁ G ∨ ﹁ H \n\n     ​                  ﹁ ( G ∨  H ) = ﹁ G ∧﹁ H \n\n     （去掉括号后析取变合取，合取变析取）\n\n3. 利用分配律，将公式化成一些合取式的析取，或化成一些析取式的合取：\n\n   - 分配律：G ∨ ( H ∧ S ) = ( G ∨ H ) ∧ ( G ∨ S ) （合取范式）\n                   G ∧ ( H ∨ S ) = ( G ∧ H ) ∨ ( G ∧ S ) （析取范式）\n\n##### 例题：\n\n![image-20220323084335490](../img/离散数学の笔记/image-20220323084335490.png)\n\n\n\n\n\n### 主范式\n\n因为范式的不唯一，为了规范化，形成唯一的主析取范式和主合取范式\n\n##### 化成主范式的步骤：\n\n- 先求出析取范式（合取范式）\n\n- 将不是极小项（极大项）的简单合取式进一步化\n- 极大项（极小项）用名称mi（Mi)表示，并用角标从小到大排序\n\n##### 极小项和极大项\n\n**定义：**\n\n在含有n个命题变项的**简单合取式**中，若每个命题变元均以文字的形式出现且仅出现一次，成这样的简单合取式为**极小项**。\n\n![image-20220323171729779](../img/离散数学の笔记/image-20220323171729779.png)\n\n要使其为真，只需要其中任何一项为真即可。\n\n要使其为假，需要所有项都为假\n\n\n\n在含有n个命题变项的**简单析取式**中，若每个命题变元均以文字的形式出现且仅出现一次，成这样的**简单析取式**为**极大项**。\n\n![image-20220323171721234](../img/离散数学の笔记/image-20220323171721234.png)\n\n若使其为真，则需每个式子都为真\n\n若使其为假，则只需其中的一个式子为假即可\n\n**解释**：①文字的形式：p,﹁p,q,﹁q这类的。②仅出现一次：p和﹁p只能有一个出现，即命题变元和其否定只能有一个出现。\n\n**说明：**\n\n- n个命题变元可以产生2^n个极小项和2^n个极大项\n\n1. 极小项（**合取**）：\n\n![image-20220302221948240](../img/离散数学の笔记/image-20220302221948240.png)\n\n- 没有两个极小项是等价的（即互不等值）\n- 每个极小项只有一组**真**值，因此可用于给极小项编码，**规律**为：命题变元与1对应，其否定与0对应\n\n2. 极大项（**析取**）：\n\n![image-20220302222040684](../img/离散数学の笔记/image-20220302222040684.png)\n\n\n\n- 没有两个极大项是相同的 \n- 每个极大项只有一组**假**值，因此可用于给极大项编码，规律为：命题变元与0对应，命题变元的否定与1对应\n\n\n\n3.配凑法求主析取范式和主合取范式\n\n- 将析取换成加法，将合取换成乘法，如(p∧q)∨(┐p∧r)代换后变成pq+p'r\n\n- 求主析取范式=>缺少的变元用**乘以x+x'**的形式补充\n\n  ```\n  pq = pq(r + r') = pqr+pqr' (乘以缺失的变元)\n  p'r = p'(q + q')r = p'qr + p'q'r\n  原式 = pqr + pqr' + p'qr + p'q'r  \n  ```\n\n- 换成离散语言![image-20220323164327707](../img/离散数学の笔记/image-20220323164327707.png)\n\n  \n\n- 求主合取范式=>将缺少的变元用**加上xx'**的形式补充\n\n  里面用到的公式：A+BC=(A+B)(A+C)\n\n- ```\n      pq + p'r                       \n   = (p+p'r)(q+p'r)\n   = (p+p')(p+r)(q+r)(q+p')\n   =(p+r)(q+r)(q+p')\n   = (p'+q +rr')(p+qq'+r)(pp'+q+r)     (补缺的变元)\n   = (p'+q+r)(p'+q+r')(p+q+r)(p+q'+r) (p+q+r)(p'+q +r)   \n  ```\n\n  换成离散语言：\n\n  ![image-20220323164434009](../img/离散数学の笔记/image-20220323164434009.png)\n\n\n\n\n\n4.将析取范式转化为合取范式\n\n例题一：\n\n![image-20220323164512564](../img/离散数学の笔记/image-20220323164512564.png)\n\n**实质**：如果将析取看成加法，合取看成乘法，非p用p'表示，则可化为：\n\n(pq')+(qr)   利用A+BC=(A+B)(A+C)\n\n=(pq'+q)(pq'+r)\n\n=(q+p)(q+q')(p+r)(q'+r)\n\n例题二：\n\n![image-20220326172328979](../img/离散数学の笔记/image-20220326172328979.png)\n\n\n\n**实质**：如果将析取看成加法，合取看成乘法，非p用p'表示，则可化为：\n\ncd+c'd'\n\n=(cd+c')(cd+d')\n\n=(c+c')(d+c')(c+d')(d+d')\n\n=(d+c')(c+d')\n\n\n\n### 主范式的用途\n\n#### 1.求公式的成真赋值和成假赋值\n\n![image-20220326173308683](../img/离散数学の笔记/image-20220326173308683.png)\n\n#### 2.判断公式的类型\n\n![image-20220326173448446](../img/离散数学の笔记/image-20220326173448446.png)\n\nA为非重言式：A的主析取范式中不含有全部的极小项\n\nA为可满足式：A的主合取范式中不含有全部的极大项\n\n#### 3.判断两个公式是否等值\n\n若两者的主析取范式或者主合取范式相同，则证明两者等值。\n\n#### 4.解决实际问题\n\n![image-20220326173842476](../img/离散数学の笔记/image-20220326173842476.png)\n\n❗解法：\n\n1.将简单命题符号化\n\n2.写出每句话的复合命题\n\n3.写出由②中的复合命题组成的合取式\n\n4.求出③中所得式子的主析取范式\n\n5.找出主析取范式的成真赋值，即为解决方案\n\n![image-20220326174225108](../img/离散数学の笔记/image-20220326174225108.png)![image-20220326180354192](../img/离散数学の笔记/image-20220326180354192.png)       极小项的成真赋值就是运算的结果\n\n### 联结词的全功能集\n\n#### 定义\n\n任何命题公式都可以由仅含S中的联结词来表示，则S是联结词全功能集\n\n说明：\n\n若S1是全功能集，则S1中加入其他联结词后构成的S2也是全功能集\n\n若S1不是全功能集，则S1中去掉一些联结词之后构成的S2也不是全功能集\n\n![image-20220326180948677](../img/离散数学の笔记/image-20220326180948677.png)\n\n#### 复合联结词：\n\n![image-20220326181140453](../img/离散数学の笔记/image-20220326181140453.png)\n\n由此可见，非，或，且联结词都可以用{↑}或者{↓}来表示，说明{↑}，{↓}都是联结词全功能集\n\n注意：\n\n{∨ ， ∧}不是全功能集，因此{∨ }，{∧ }也不是全功能集\n\n\n\n### 组合电路\n\n#### 逻辑门：与门，非门，或门\n\n![image-20220326181608529](../img/离散数学の笔记/image-20220326181608529.png)例题：楼梯的灯由两个开关控制，x,y为开关的状态，F为灯的状态，打开为1，关闭为0，请设计这样一个电路。\n\n| x    | y    | F(x,y) |\n| ---- | ---- | ------ |\n| 0    | 0    | 1      |\n| 0    | 1    | 0      |\n| 1    | 0    | 0      |\n| 1    | 1    | 1      |\n\n由此可见，F的极小项是m0和m3（成真赋值），故根据真值表可以写出其主析取范式，进行化简之后，画出电路图\n\n![image-20220326182456376](../img/离散数学の笔记/image-20220326182456376.png)\n\n### 推理理论\n\n#### 定义\n\n对于每组赋值，若满足下列两种情况：①条件为假 ②条件为真，结果为真。则称条件→结论的推理正确，否则推理不正确（即条件为真，结论为假）\n\n#### 判断推理是否正确的方法\n\n- 真值表法\n\n  将所有变元可能的取值情况列成真值表，若对于每组赋值，都满足A→B为真，则证明推理正确\n\n- 等值演算法\n\n  将A→B经过等值验算，如果其结果为1，则证明推理正确\n\n- 主析取范式法\n\n  将A→B转化为主析取范式，若其包括了所有的极小项（2^n个），则说名推理正确\n\n- 构造证明法\n\n#### 推理定律\n\n![image-20220326183553084](../img/离散数学の笔记/image-20220326183553084.png)\n\n","tags":["笔记"],"categories":["数学笔记"]},{"title":"一些好用的网站","url":"/2022/02/28/一些好用的网站/","content":"\n下面是自己最近冲浪看到的一些很好的网站，分享给你：\n\n- 可以提高图片分辨率的网站：\n\n  https://bigjpg.com/\n\n- 超喜欢的练习打字网站（小白的我从练习打字开始）\n\n  https://www.typing.com/\n\n- 网道，简洁舒适的编程教程（阮一峰前辈yyds)：\n\n  https://wangdoc.com/\n\n- STL超全工具书，方便查询：\n\n  https://blog.csdn.net/weixin_45761327/article/details/107561697\n\n- adobe全家桶（2020年的）：\n\n  https://www.yuque.com/books/share/205ec53c-5013-4bdb-ad02-ac96cc761203/nnun78\n","tags":["分享"],"categories":["分享"]},{"title":"2048小游戏","url":"/2022/02/27/2048/","content":"\n先移动，将arr数组中的数据进行合并\n\n再判断游戏是否结束\n\n再更新界面（包括更新div中的innerHTML和更新分数）\n\n这是我制作的第一个小游戏🙆‍♀️\n\n自学了HTML，CSS，和JS的一点皮毛🤦‍♀️\n\n只能说一个这个有些稚嫩的成果，基本啥都没有，简单的界面和逻辑，唯一的优点是它确实能跑，缺点是“能跑”的补集😅\n\n\n\n这个游戏的思路：\n首先创建一个类\n\n类中有以下东西：\n\n①成员变量：\n\n- 一个二维数组，负责记录当前位置的分数（对应就是屏幕上的16个块）\n- 当前的分数\n- 当前游戏的状态，运行（1）or已经结束（0）\n\n②成员函数\n\n\n\n- 游戏的初始化\n\n1. 分数初始化为0\n2. 对16个方格对应的值进行赋值为0\n3. 当前的游戏状态设为1（正在运行）\n4. 调用生成随机数函数两次，生成两个随机数\n5. 调用更新视图函数，\n\n\n\n- 生成随机数\n\n1. 分别随机生成行和列\n2. 如果对应的元素为0的话，就说明这个位置是可以的\n3. 则在随机生成2或者4，这里用到了Math.random()，是令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值，所以我们要以均等的概率生成2或4，代码就是`var num = Math.random()>0.5?2:4;`\n\n\n\n- 更新当前界面（JS与HTML链接的地方）\n\n1. 两层for循环遍历data数组，通过getElementById来获取[i][j]位置上的方格,赋值给变量div\n2. 如果data[i][j]的值不为0 通过div.innerHTML把格子显示的数值改成data[i][j]（更新数据），通过div.className将格子代表的数值也进行更新\n3. 如果data[i][j]的值为0，格子内什么也不显示，对应设置div.innerHTML=''，div.className='grid'\n\n\n\n- 更新屏幕上的分数\n\n通过getElementById来获得score01（当前分数）的标签，将其中的innerHTML改为当前的分数（this.score）\n\n\n\n- 检测游戏状态\n\n1. 如果this.status==0(游戏结束）将this.score赋值给score02(结束时的分数）的innerHTML\n\n\n\n- 判断游戏是否结束（没结束返回false，结束返回true）\n\n没有结束的三种情况：\n\n1. 两层循环遍历data ，如果data[i][j]为零，返回false（① 数组中还有0）\n2. 在遍历中，如果j<3并且data[i][j]等于data[i][j+1]，返回false（②左右相邻的还有相同的）\n3. 在遍历中，如果i<3并且data[i][j]等于data[i+1][j]，返回false（③上下相邻的还有相同的）\n4. 如果遍历完都没有返回，说明游戏结束了，返回true\n\n\n\n- 方格向左移动\n\n1. 用String函数将变动前的data二维数组转化成一个字符串before，以便变动之后与变动后的data数组比较。\n2. 遍历每一行，调用左移一行的函数\n3. 用String函数将变动后的data二维数组转化成一个字符串after，比较before和after\n4. 如果不相等，说明布局变化了，需要判断游戏是否结束，如果游戏结束，则将游戏状态status设为0，如果游戏没有结束，调用更新当前界面函数\n\n\n\n- 左移一行的函数：\n\n1. 遍历当前行的所有列，得到当前元素[i][j]的右边不为0的第一个位置[i][nextj]\n\n2. 如果当前元素为0，左移之后直接会覆盖，所以就让当前元素等于data[i][nextj]，并把data[i][nextj]置0，让j--（要从当前位置继续遍历）\n\n3. 如果当前元素不为0且等于它右边不为0的第一个元素，则左移以后两个方块会合并为一个，并将data*2，所以this.data[i][j]*=2；并将分数加上。\n\n   \n\n下面是我做的时候写的思维导图，希望对你有帮助：\n\n![2048](../img/我做的第一个小游戏—2048/2048-16462039259381.png)\n\n里面用到的函数：\n\n1. 更新当前视图\n\n![更新视图](../img/我做的第一个小游戏—2048/更新视图.png)\n\n2. 移动本行（这里以向左移动为例）\n\n   ![更新视图(1)](../img/我做的第一个小游戏—2048/更新视图(1).png)\n\n3. 生成随机位置\n\n![更新视图(2)](../img/我做的第一个小游戏—2048/更新视图(2).png)\n\n\n\n链接如下，要不点进去看看，哎喂看看我的配色也行啊！\n\n[2048小游戏](https://zhiruozzy.cn/Web/)\n\n### 下面是代码部分：\n\n#### HTML部分：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"stylesheet\" href=\"./css/index.css\">\n    <link rel=\"shortcut icon\" href=\"https://www.2048.org/favicon.ico\">\n    <title>2048</title>\n</head>\n\n<body>\n    <!-- 游戏标题 -->\n    <header>\n        <h1>2048</h1>\n        <!-- 当herf链接会空时会刷新页面，也就达到了remake的目的 -->\n        <a href=\" \" id=\"newgamebutton\">新游戏</a>\n        <p class=\"grade\">分数：<span id=\"score01\">999999999</span> </p>\n    </header>\n    <div class=\"all\">\n        <div class=\"cell\" id=\"c00\"></div>\n        <div class=\"cell\" id=\"c01\"></div>\n        <div class=\"cell\" id=\"c02\"></div>\n        <div class=\"cell\" id=\"c03\"></div>\n        <div class=\"cell\" id=\"c10\"></div>\n        <div class=\"cell\" id=\"c11\"></div>\n        <div class=\"cell\" id=\"c12\"></div>\n        <div class=\"cell\" id=\"c13\"></div>\n        <div class=\"cell\" id=\"c20\"></div>\n        <div class=\"cell\" id=\"c21\"></div>\n        <div class=\"cell\" id=\"c22\"></div>\n        <div class=\"cell\" id=\"c23\"></div>\n        <div class=\"cell\" id=\"c30\"></div>\n        <div class=\"cell\" id=\"c31\"></div>\n        <div class=\"cell\" id=\"c32\"></div>\n        <div class=\"cell\" id=\"c33\"></div>\n\n    </div>\n    <div class=\"gameover\">\n        <p>\n            游戏结束！<br> 分数：<span id=\"score02\">999999999</span> <br>\n            <a href=\"\">再来一次</a>\n        </p>\n    </div>\n    <script src=\"./js/index.js\"></script>\n</body>\n\n</html>\n```\n\n#### CSS部分\n\n```css\n* {\n    padding: 0;\n    margin: 0;\n    font-family: Arial;\n    text-decoration: none;\n}\n\nheader{\n\tdisplay: block;\n\tmargin:10px auto;\n\twidth:100%;\n\ttext-align: center;\n}\n/* 设置“2048”的字体 */\nheader h1{\n\t\n\tfont-family: Arial, Helvetica, sans-serif;\n\tfont-size: 45px;\n\t/* 字体加粗 */\n\tfont-weight: 700px;\n}\n    /*设置游戏按钮 */\nheader #newgamebutton{\n\tdisplay: block;\n\tmargin:8px auto;\n\theight: 30px;\n\twidth:130px;\n\t/* 背景颜色 */\n\tbackground-color: #8f7a66;\n\tfont-family: Arial, Helvetica, sans-serif;\n\tfont-size: 18px;\n\t/* 字体颜色 */\n\tcolor: white;\n\t/* 字体垂直居中 */\n\tline-height: 30px;\n\t/* 设置圆角 */\n    border-radius: 10px;\n\t/* 去除下划线 */\n\ttext-decoration: none;\n}\n/* 设置鼠标悬浮样式 */\nheader #newgamebutton:hover{\n\tbackground-color: #9f8b77;\n}\n\nbody {\n    background-color: #FAF8EF;\n}\n\n.grade {\n    width: 500px;\n    margin: 0 auto;\n    margin-top: 20px;\n    font-size: 40px;\n    text-align: center;\n    font-weight: bold;\n    color: #776E65;\n}\n\n.all {\n    width: 500px;\n    height: 500px;\n    margin: auto;\n    background-color: #BBADA0;\n    border-radius: 10px;\n}\n\n.cell {\n    width: 100px;\n    height: 100px;\n    margin-top: 20px;\n    margin-left: 20px;\n    background-color: #ccc0b3;\n    float: left;\n    border-radius: 5px;\n    font-size: 24px;\n    font-weight: bold;\n    color: #776E65;\n    line-height: 100px;\n    text-align: center;\n}\n\n.n2 {\n    background-color: rgb(237, 229, 218);\n}\n\n.n4 {\n\tbackground-color: rgb(235, 216, 191);\n}\n\n.n8 {\n\tbackground-color: rgb(242, 177, 123);\n}\n\n.n16 {\n\tbackground-color: rgb(246, 147, 92);\n}\n\n.n32 {\n\tbackground-color: rgb(242, 116, 86);\n}\n\n.n64 {\n\tbackground-color: rgb(243, 81, 46);\n}\n\n.n128 {\n\tbackground-color: rgb(255, 210, 0);\n}\n\n.n256 {\n\tbackground-color: rgb(230, 209, 81);\n}\n\n.n512 {\n\tbackground-color: rgb(204, 164, 11);\n}\n\n.n1024 {\n\tbackground-color: rgb(143, 75, 56);\n}\n\n.n2048 {\n\tbackground-color: rgb(142, 62, 31);\n}\n\n.n4096 {\n\tbackground-color: rgb(106, 52, 39);\n}\n\n.n8192 {\n\tbackground-color: rgb(110, 107, 65);\n}\n\n.gameover {\n    display: none;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background: rgba(0, 0, 0, 0.3);\n}\n\n.gameover p {\n    width: 400px;\n    height: 300px;\n    background-color: white;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -200px;\n    border: solid 1px black;\n    border-radius: 10px;\n    font-size: 40px;\n    line-height: 100px;\n    text-align: center;\n}\n\n.gameover p a {\n    background-color: #8F7A66;\n    border-radius: 5px;\n    padding: 15px;\n    color: white;\n}\n```\n\n#### JS部分（核心）：\n\n```javascript\nvar game = {\n    data: [], //存放数据\n    score: 0, //分数\n    status: 0, //当前状态，时刻的监听，时刻的需要改变      游戏运行中的状态，结束的状态\n    gameover: 0,\n    gamerunning: 1,\n\n\n    // 开始游戏的方法\n    start: function() {\n        this.score = 0;\n        this.data = [\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0]\n        ]\n        this.status = this.gamerunning;\n        this.randomNum()\n        this.randomNum()\n        this.dataView()\n    },\n    // 随机数的方法\n    randomNum: function() {\n        for (;;) {\n            var r = Math.floor(Math.random() * 4);\n            var c = Math.floor(Math.random() * 4);\n            if (this.data[r][c] == 0) {\n                var num = Math.random() > 0.5 ? 2 : 4;\n                this.data[r][c] = num;\n                break;\n            }\n        }\n    },\n    // 更新的视图\n    dataView: function() {\n        for (var r = 0; r < 4; r++) {\n            for (var c = 0; c < 4; c++) {\n                var div = document.getElementById('c' + r + c);\n                if (this.data[r][c] != 0) {\n                    div.innerHTML = this.data[r][c];\n                    div.className = 'cell n' + this.data[r][c]\n                } else {\n                    div.innerHTML = ''\n                    div.className = 'cell'\n                }\n            }\n        }\n        document.getElementById('score01').innerHTML = this.score; //设置游戏分数\n\n        // 监测游戏状态\n        if (this.status == this.gameover) {\n            document.getElementById('score02').innerHTML = this.score;\n            document.getElementsByClassName('gameover')[0].style.display = 'block'\n        } else {\n            document.getElementsByClassName('gameover')[0].style.display = 'none'\n        }\n    },\n    // 判断游戏是否结束的方法   游戏没结束返回false 结束返回true\n    isgameover: function() {\n        for (var r = 0; r < 4; r++) {\n            for (var c = 0; c < 4; c++) {\n                // 没有结束，三种情况：：1.数组中还有0 2.左右相邻的有相同的  3.上下相邻有相同的\n                if (this.data[r][c] == 0) {\n                    return false\n                }\n                if (c < 3) {\n                    if (this.data[r][c] == this.data[r][c + 1]) {\n                        return false\n                    }\n                }\n                if (r < 3) {\n                    if (this.data[r][c] == this.data[r + 1][c]) {\n                        return false\n                    }\n                }\n            }\n        }\n        return true; //表示游戏已经结束\n    },\n\n    // 左移动\n    moveLeft: function() {\n        var before = String(this.data) //移动之前\n            //处理移动的逻辑\n\n        for (var r = 0; r < 4; r++) {\n            this.moveLeftInRow(r);\n        }\n\n        var after = String(this.data) //移动之后\n        if (before != after) {\n            this.randomNum()\n            if (this.isgameover()) {\n                this.status = this.gameover;\n            }\n            this.dataView()\n        }\n    },\n    moveLeftInRow: function(r) { //单独处理每一行的逻辑\n        for (var c = 0; c < 3; c++) {\n            var nextc = this.getNextInRow(r, c);\n            if (nextc != -1) {\n                if (this.data[r][c] == 0) {\n                    this.data[r][c] = this.data[r][nextc];\n                    this.data[r][nextc] = 0;\n                    c--;\n                } else if (this.data[r][c] == this.data[r][nextc]) {\n                    this.data[r][c] *= 2;\n                    this.score += this.data[r][c]\n                    this.data[r][nextc] = 0\n                }\n            } else {\n                break;\n            }\n        }\n    },\n    getNextInRow: function(r, c) {\n        for (var i = c + 1; i < 4; i++) {\n            if (this.data[r][i] != 0) {\n                return i\n            }\n        }\n        return -1;\n    },\n\n    // 右移动\n    moveRight: function() {\n        var before = String(this.data) //移动之前\n        for (var r = 3; r >= 0; r--) {\n            this.moveRightInRow(r);\n        }\n        var after = String(this.data) //移动之后\n        if (before != after) {\n            this.randomNum()\n            if (this.isgameover()) {\n                this.status = this.gameover;\n\n            }\n            this.dataView()\n        }\n    },\n    moveRightInRow: function(r) { //单独处理每一行的逻辑\n        for (var c = 3; c >= 0; c--) {\n            var nextc = this.getNextInRowa(r, c);\n            if (nextc != -1) {\n                if (this.data[r][c] == 0) {\n                    this.data[r][c] = this.data[r][nextc];\n                    this.data[r][nextc] = 0;\n                    c++;\n                } else if (this.data[r][c] == this.data[r][nextc]) {\n                    this.data[r][c] *= 2;\n                    this.score += this.data[r][c]\n                    this.data[r][nextc] = 0\n                }\n            } else {\n                break;\n            }\n        }\n    },\n    getNextInRowa: function(r, c) {\n        for (var i = c - 1; i >= 0; i--) {\n            if (this.data[r][i] != 0) {\n                return i\n            }\n        }\n        return -1;\n    },\n    // 上移动\n    moveTop: function() {\n        var before = String(this.data) //移动之前\n        for (var c = 0; c < 4; c++) {\n            this.moveTopInRow(c);\n        }\n        var after = String(this.data) //移动之后\n        if (before != after) {\n            this.randomNum()\n            if (this.isgameover()) {\n                this.status = this.gameover;\n\n            }\n            this.dataView()\n        }\n    },\n    moveTopInRow: function(c) { //单独处理每一列的逻辑\n        for (var r = 0; r < 3; r++) {\n            var nextr = this.getNextInRowaa(r, c);\n            if (nextr != -1) {\n                if (this.data[r][c] == 0) {\n                    this.data[r][c] = this.data[nextr][c];\n                    this.data[nextr][c] = 0;\n                    r--;\n                } else if (this.data[r][c] == this.data[nextr][c]) {\n                    this.data[r][c] *= 2;\n                    this.score += this.data[r][c]\n                    this.data[nextr][c] = 0\n                }\n            } else {\n                break;\n            }\n        }\n    },\n    getNextInRowaa: function(r, c) {\n        for (var i = r + 1; i < 4; i++) {\n            if (this.data[i][c] != 0) {\n                return i\n            }\n        }\n        return -1;\n    },\n    // 下移动\n    moveButtom: function() {\n        var before = String(this.data) //移动之前\n        for (var c = 3; c >= 0; c--) {\n            this.moveButtomInRow(c);\n        }\n        var after = String(this.data) //移动之后\n        if (before != after) {\n            this.randomNum()\n            if (this.isgameover()) {\n                this.status = this.gameover;\n\n            }\n            this.dataView()\n        }\n    },\n    moveButtomInRow: function(c) { //单独处理每一列的逻辑\n        for (var r = 3; r >= 0; r--) {\n            var nextr = this.getNextInRowaaa(r, c);\n            if (nextr != -1) {\n                if (this.data[r][c] == 0) {\n                    this.data[r][c] = this.data[nextr][c];\n                    this.data[nextr][c] = 0;\n                    r++;\n                } else if (this.data[r][c] == this.data[nextr][c]) {\n                    this.data[r][c] *= 2;\n                    this.score += this.data[r][c]\n                    this.data[nextr][c] = 0\n                }\n            } else {\n                break;\n            }\n        }\n    },\n    getNextInRowaaa: function(r, c) {\n        for (var i = r - 1; i >= 0; i--) {\n            if (this.data[i][c] != 0) {\n                return i\n            }\n        }\n        return -1;\n    },\n\n}\n\n\ngame.start()\n\n\n\ndocument.onkeydown = function(e) {\n    if (e.keyCode == 37) {\n        game.moveLeft()\n    }\n    if (e.keyCode == 39) {\n        game.moveRight()\n    }\n    if (e.keyCode == 38) {\n        game.moveTop()\n    }\n    if (e.keyCode == 40) {\n        game.moveButtom()\n    }\n}\n}\n\n```\n\n","tags":["游戏"],"categories":["自制"]},{"title":"也茫然 还好有勇敢","url":"/2022/02/26/也茫然-还好有勇敢/","content":"### 壹\n　　一直都是一个只有三分钟热度的人\n\n　　对所有好玩的事情都投以极大的热情，一刻也等待不了，但一旦细究其实现的方法和难度，便会败下阵来。\n\n　　所以，这个博客的诞生对我来说简直就是一个奇迹。进入计算机专业，有时查找资料时无意访问到别人的博客，心生羡慕，便立即涌现出自己也制作一个的冲动，可自己上手，才发现原来绚丽的页面的搭建，不仅需要学习HTML，CSS，还需要学习JavaScript，命令行操作。\n\n　　在蓝图的孵化器的项目中，趁着寒假的闲暇时间，我才慢慢的学习，搭建了这个博客，并自制了2048小游戏。当完成了之后回望自己的学习历程，不禁感慨万千，故写下这篇小记。　　\n\n\n\n------\n\n\n\n### 贰\n　　都说计算机专业是活到老学到老，可在高中都是老师手把手教授，什么做题方法、知识串联，老师都不厌其烦的进行讲解，做这次任务，才明白，我总要学会，自己去面对所有的难。\n\n　　还没有进入大学时，总是想象着，课堂上教授的谈笑风生，一切的知识都是那么新奇而又有趣，可当我步入校园，才发现理论和现实的鸿沟。上课听的云里雾里，作业也不太会做，课后又得自己找教程再次学习，刚开始的时候，我特别不适应这样超负荷的生活，一想到自己捉襟见肘的生活，眼泪就止不住地往下掉（真是个爱哭鬼）。\n\n　　两周下来，我有些开窍。我以前曾无比渴望在受伤难过时、孤独无依时，得到其他人的回应、理解和陪伴。于是一emo就打开聊天框寻求安慰。可朋友能给我一时的安慰和鼓励，但这毕竟都是有限的，大家都有自己的事情要做，怎么能整天麻烦别人。我总要面对没人帮忙、没人支持、没人嘘寒问暖的日子，最终解决问题还是要靠自己。每个人的生活，无论酸甜苦辣，都要自己去品尝。每个人的道路，无论顺遂还是曲折，都要自己去行走。\n\n　　后来，我渐渐找到了平衡的方法，课前要先预习，这样上课就可以跟上老师的步伐，大学，真就是大不了自己学，累的时候就少说闲话、少想乱七八糟的事，困的时候就早睡不熬夜，心里感觉苦了，赶紧拿颗糖塞嘴里。我不断给自己打气说，小周小周冲冲冲。\n\n　　我曾害怕面对一切艰难险阻，直到生活给了我一道道坎，才教会了我如何在挫折和痛苦中一步一步变强。　　\n\n\n\n------\n\n\n\n### 叁\n\n　　蓝图的第一个任务就是部署自己的网页，并自学HTML，CSS，JavaScript制作2048小游戏。前一周，我兴冲冲的打开HTML和CSS的教程，心想：不过如此嘛。可拧巴又好强的我不想只部署一个网站，我想把网站做成博客，把小游戏嵌到里面。可真正到了部署自己的博客的时候才发现，原来很多事情并不是在界面化的界面做的，而是要涉及到那个黑框框样子的命令行，里面复杂的指令和只要随便输错一点点就会乱七八糟弹出来一大堆不认识的英文，真是让我这个从未接触过命令行的小白头大。\n\n　　在网上大海捞针般的搜索云开发和静态网站托管的知识，了解其中的机理和命令行的内容，我坐在电脑前就忘了时间。\n\n　　开始是，出了错误但不知道错哪了，只能删除自己之前已经部署了大部分的网站，推到重来，有放不下的吧，毕竟是自己费了好大功夫才做好的，可如果不重来，依照现在自己这个水平也修不好它呀（有点对不起那些“胎死腹中”的网页哈哈哈）。\n\n　　当时就想起了曾经在书上看到的一个故事：一个人上火车时不小心掉了一只新鞋，等火车开动了他才发现。这时，他毫不犹豫地把另一只鞋也从窗口扔了出去。其他乘客很不理解，他解释说，那双鞋不论多么昂贵，对他而言都已经失去作用了，而捡到这双鞋的人就不同了。所以，与其留一只对自己无用的鞋，倒不如选择放弃，或许会成全另一个人呢？\n\n　　一次次的推倒重来，在不断的试错中，我的内心独白常常是：\n\n　　“怎么又错了！这次又是哪里不对\"\n\n　　\"为什么我本地预览出来都在好着呢，推送到终端就不行了\"\n\n　　”原来我找了二十分钟的错误是冒号后少了一个空格 ！“\n\n　　可渐渐的，我的命令敲得越来越顺了，我的操作也越来越熟悉了，面对错误，我可以不用推到重来（因为我已经能大概看懂命令行的提示了），甚至英语都有所进步（命令行里都是英文，教程也好多都是英文）。\n\n　　原来啊，只要努力坚持下去，真的有可能看到光明。\n\n　　原来啊，如果我只想看到结果再出发，那我将永远不会知道结果在哪儿。\n\n------\n\n\n\n### 肆\n\n　　又又又坐在电脑前捣鼓了一下午，乱七八糟的命令行错误真是让人头大，搭建一个网站真的对我这种小白真的太不容易了。回忆下来，这两周我竟然捣鼓了这么多东西，先在云开发中先搭建了个博客，又因为不好访问把把博客迁移到了GitHub，顺便学会了搭梯子（感谢lyx的北大梯子🙆‍♀️），但因为GitHub网页每次更新不及时，我又买服务器，买域名，给域名备案，给服务器备案，申请SSL证书，买COS资源包，部署SSL证书，在云服务器用Linux命令行指示。这一路对我来说很艰难，虽然不属于算法题那种烧脑类型的，但里面涉及到的全都是我从未涉足的知识，终于终于，终于部署完成了！真的整个人都瘫在沙发上。天生拧巴的人终于和自己硬刚了一次。\n\n　　最后，以一句我很喜欢的话结尾吧。\n\n> 我与我周旋久，宁作我。\n","tags":["随笔"],"categories":["小记"]}]