
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>链表第一次作业 - 芷若</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="问题 B: 链表排序题目描述已知一个正整数组成的无序序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后将这个链表进行排序，使得排序后的链表为递增序列。正,"> 
    <meta name="author" content="芷若"> 
    <link rel="alternative" href="atom.xml" title="芷若" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="链表第一次作业 - 芷若"/>
    <meta name="twitter:description" content="问题 B: 链表排序题目描述已知一个正整数组成的无序序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后将这个链表进行排序，使得排序后的链表为递增序列。正,"/>
    
    
    
    
    <meta property="og:site_name" content="芷若"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="链表第一次作业 - 芷若"/>
    <meta property="og:description" content="问题 B: 链表排序题目描述已知一个正整数组成的无序序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后将这个链表进行排序，使得排序后的链表为递增序列。正,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.0.0"><link rel="stylesheet" href="/css/prism-vs.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body class="loading">
    <span id="config-title" style="display:none">芷若</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://zhiruozzy.cn"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">链表第一次作业</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">链表第一次作业</h1>
        <div class="stuff">
            <span>三月 18, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E4%BD%9C%E4%B8%9A/" rel="tag">作业</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="问题-B-链表排序"><a href="#问题-B-链表排序" class="headerlink" title="问题 B: 链表排序"></a>问题 B: 链表排序</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知一个正整数组成的无序序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后将这个链表进行排序，使得排序后的链表为递增序列。正整数的输入用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。在排序的过程中，你可以自己选择排序算法（冒泡排序、选择排序等），但必须是通过修改结点的指针域来进行排序，而不是对结点的数据域进行修改。程序结束后要释放所有节点占据的空间。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>一个元素个数未知的正整数序列，以输入“-1”结束，输入“-1”前至少输入一个正整数。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>经过排序后的链表，<strong>每个元素后有一个空格，注意最后一个元素后只有换行符。</strong><br>数据最多的测试用例节点数在1000这个数量级，所有整数可以用int型存储。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>49 38 65 97 76 13 27 49 -1
</code></pre>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>The new list is:13 27 38 49 49 65 76 97
</code></pre>
<h3 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode():val(0),next(nullptr){}
    ListNode(int x):val(x),next(nullptr){}
    ListNode(int x,ListNode *next):val(x),next(next){}
};
//链表排序
ListNode* sortList(ListNode* head) {
    //递归终止条件:cut到每一部分只剩下1个结点或0个结点
    if (head == NULL || head->next == NULL)
        return head;
    //利用快慢指针找到链表的中点（slow)
    ListNode* fast = head->next;
    ListNode* slow = head;
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }
    //记录后一段的头结点
    ListNode* nextHead = slow->next;
    //断开链表
    slow->next = nullptr;
    //继续递归cut
    ListNode* left = sortList(head);
    ListNode* right = sortList(nextHead);

    //合并
    //建立哑结点
    ListNode* dummy = new ListNode;
    //cur不断后移扩充链表
    ListNode* cur = dummy;
    //利用双指针合并
    while (left && right) {
        if (left->val < right->val) {
            cur->next = left;
            left = left->next;
        }
        else {
            cur->next = right;
            right = right->next;
        }
        cur = cur->next;
    }
    cur->next = left ? left : right;
    return dummy->next;

}

//输出链表的值
void print(ListNode* head) {
    cout << "The new list is:";
    while (head) {
        if (head->next) {
            cout << head->val << " ";
        }
        else {
            cout << head->val << endl;
        }
        head = head->next;
    }
}

int main() {
    //尾插法
    ListNode* head = new ListNode;
    ListNode* tail = head;
    int x = 0;
    cin >> x;
    while (x != -1) {
        ListNode* temp = new ListNode;
        temp->val = x;
        tail->next = temp;
        tail = temp;
        cin >> x;
    }
    sortList(head);
    print(head->next);
    return 0;
}
    
    5 -1
        
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="问题C"><a href="#问题C" class="headerlink" title="问题C"></a>问题C</h2><p>我也不知道我错哪里了，好吧通过讨论群里麦神的提示我知道了，</p>
<p>只需要把<code>while(str[0]  != &#39;-&#39;)</code>改成<code>while (str.compare(&quot;-1&quot;))</code> 就行了!🤦‍♀️枯了</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
#include <ctype.h>
using namespace std;

struct ListNode {
    char val;
    ListNode* next;
    ListNode():val(0),next(nullptr){}
    ListNode(int x):val(x),next(nullptr){}
    ListNode(int x,ListNode *next):val(x),next(next){}
};
//链表排序
ListNode* sortList(ListNode* head) {
    //递归终止条件:cut到每一部分只剩下1个结点或0个结点
    if (head == NULL || head->next == NULL)
        return head;
    //利用快慢指针找到链表的中点（slow)
    ListNode* fast = head->next;
    ListNode* slow = head;
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }
    //记录后一段的头结点
    ListNode* nextHead = slow->next;
    //断开链表
    slow->next = nullptr;
    //继续递归cut
    ListNode* left = sortList(head);
    ListNode* right = sortList(nextHead);

    //合并
    //建立哑结点
    ListNode* dummy = new ListNode;
    //cur不断后移扩充链表
    ListNode* cur = dummy;
    //利用双指针合并
    while (left && right) {
        if (left->val < right->val) {
            cur->next = left;
            left = left->next;
        }
        else {
            cur->next = right;
            right = right->next;
        }
        cur = cur->next;
    }
    cur->next = left ? left : right;
    return dummy->next;

}

//输出链表的值
void print(ListNode* head,char ch) {
    if (head == NULL) {
        if (ch != 'C') {
            cout << "There is no item in " << ch << " list." << endl;
        }
        else
        {
            cout << "There is no item in " << ch << " list.";
        }
        return;
    }
    cout << "The list "<<ch<<" is: ";
    while (head) {
        if (head->next) {
            cout << head->val << " ";
        }
        else {
            cout << head->val << endl;
        }
        head = head->next;
    }
}

//分割链表
void cut(ListNode* head,ListNode*A,ListNode*B,ListNode*C) {
    ListNode* temp = head;
    ListNode* tempA = A;
    ListNode* tempB = B;
    ListNode* tempC = C;
    while (temp->next) {
        if (isalpha(temp->next->val)) {
            tempA->next = temp->next;
            temp->next = temp->next->next;
            tempA = tempA->next;
        }
        else if (isdigit(temp->next->val)) {
            tempB->next = temp->next;
            temp->next = temp->next->next;
            tempB = tempB->next;
        }
        else {
            tempC->next = temp->next;
            temp->next = temp->next->next;
            tempC = tempC->next;
        }
    }
    tempA->next = nullptr;
    tempB->next = nullptr;
    tempC->next = nullptr;
}

int main() {
    //尾插法
    ListNode* head = new ListNode;
    ListNode* tail = head;
    string str ;
    cin >> str;
    while (str[0]  != '-') {
        ListNode* temp = new ListNode;
        temp->val = str[0];
        tail->next = temp;
        tail = temp;
        cin >> str;
    }
    ListNode* A = new ListNode;
    ListNode* B = new ListNode;
    ListNode* C = new ListNode;
    cut(head,A,B,C);
    sortList(A);
    sortList(B);
    sortList(C);
    print(A->next,'A');
    print(B->next,'B');
    print(C->next,'C');

    return 0;
}
    
    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="问题D"><a href="#问题D" class="headerlink" title="问题D"></a>问题D</h3><p>我还是不知道自己错那了</p>
<p>嘿嘿，找出一个错误，是没有判断A比B短的情况，增加了之后变成90分了</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode() :val(0), next(nullptr) {}
    ListNode(int x) :val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) :val(x), next(next) {}
};

int  get(ListNode* head, ListNode* tail) {
    int count = 0;
    int x = 0;
    cin >> x;
    while (x != -1) {
        ListNode* temp = new ListNode;
        count++;
        temp->val = x;
        tail->next = temp;
        tail = temp;
        cin >> x;
    }
    return count;
}
bool cmp(ListNode* h1, ListNode* h2) {
    ListNode* i = h1;
    while (i) {
        ListNode* j = h2;
        ListNode* k = i;
        while (j) {
            if (k->val == j->val) {
                k = k->next;
                j = j->next;
            }
            else {
                break;
            }
        }
        i = i->next;
        if (j == nullptr) {
            return true;
        }
    }
    return false;
}
int main() {
    //尾插法
    ListNode* head1 = new ListNode;
    ListNode* tail1 = head1;
    ListNode* head2 = new ListNode;
    ListNode* tail2 = head2;
    int count1= get(head1, tail1);
    int count2=get(head2, tail2);
    if (count2 > count1) {
        cout << "ListB is not the sub sequence of ListA.";
        return 0;
    }
    bool ret = cmp(head1->next, head2->next);
    if (ret) {
        cout << "ListB is the sub sequence of ListA.";
    }
    else {
        cout << "ListB is not the sub sequence of ListA.";
    }
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="问题E"><a href="#问题E" class="headerlink" title="问题E"></a>问题E</h2><p>✌耶耶耶我一遍过了</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode() :val(0), next(nullptr) {}
    ListNode(int x) :val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) :val(x), next(next) {}
};

void func(ListNode* head,int s1,int t1,int s2,int t2){
    ListNode* cur = head;
    int count = 0;
    //记录几个重要节点
    while (count != s1 - 1) {
        cur = cur->next;
        count++;
    }
    ListNode* pre1 = cur;
    ListNode* x1 = cur->next;
    while (count != t1) {
        cur = cur->next;
        count++;
    }
    ListNode* nex1 = cur;
    while (count != s2 - 1) {
        cur = cur->next;
        count++;
    }
    ListNode* pre2 = cur;
    while (count != t2) {
        cur = cur->next;
        count++;
    }
    ListNode* nex2 = cur;
    ListNode* y2 = cur->next;
     
    //交换节点
    //注意这里要分两种情况
    //1.两个区间挨在一起，如[1,2] [3,6],即左区间的右边就是右区间
    //2.两个区间没有挨在一起，如[1,2] [5,6]
    
    pre1->next = pre2->next;
    if (t1 + 1 == s2) {
        nex2->next = x1;
    }
    else {
        nex2->next = nex1->next;

        pre2->next = x1;
    }
    nex1->next = y2;
}
//打印链表
void print(ListNode* head) {
    cout << "The new list is:";
    while (head) {
        if (head->next) {
            cout << head->val << " ";
        }
        else {
            cout << head->val << endl;
        }
        head = head->next;
    }
}
int main() {
    //尾插法
    ListNode* head = new ListNode;
    ListNode* tail = head;
    int x = 0;
    cin >> x;
    while (x != -1) {
        ListNode* temp = new ListNode;
        temp->val = x;
        tail->next = temp;
        tail = temp;
        cin >> x;
    }
    int s1, t1, s2, t2;
    cin >> s1 >> t1 >> s2 >> t2;
    func(head,s1,t1,s2,t2);
    print(head->next);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="问题F"><a href="#问题F" class="headerlink" title="问题F"></a>问题F</h2><pre class="line-numbers language-c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode() :val(0), next(nullptr) {}
    ListNode(int x) :val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) :val(x), next(next) {}
};

void get(ListNode* head, ListNode* tail) {
    int x = 0;
    cin >> x;
    while (x != -1) {
        ListNode* temp = new ListNode;
        temp->val = x;
        tail->next = temp;
        tail = temp;
        cin >> x;
    }
    tail->next = nullptr;
}

void merge(ListNode* h1, ListNode* h2) {
    if (h1->next == nullptr || h2->next == NULL) {
        return;
    }
    ListNode* cur1 = h1;
    ListNode* cur2 = h2;
    while (cur1->next && cur2->next) {
        ListNode* nex2 = cur2->next;
        if (cur1->val<nex2->val && cur1->next->val>nex2->val) {
            cur2->next = cur2->next->next;
            nex2->next = cur1->next;
            cur1->next = nex2;

        }
        cur1 = cur1->next;
         while (cur2->next&&cur1->val == cur2->next->val)
                cur2 = cur2->next;
    }
    if (cur2->next) {
        cur1->next = cur2->next;
        cur2->next = nullptr;
    }

}
//输出链表的值
void print(ListNode* head, char ch) {
    if (head == NULL) {
        cout << "There is no item in " << ch << " list." << endl;
        return;
    }
    cout << "The list " << ch << " is: ";
    while (head) {
        if (head->next) {
            cout << head->val << " ";
        }
        else {
            cout << head->val << endl;
        }
        head = head->next;
    }
}
int main() {
    //尾插法
    ListNode* head1 = new ListNode;
    ListNode* tail1 = head1;
    ListNode* head2 = new ListNode;
    ListNode* tail2 = head2;
    get(head1, tail1);
    get(head2, tail2);
    merge(head1, head2);
    print(head1->next, 'A');
    print(head2->next, 'B');
    return 0;

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-B-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">问题 B: 链表排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5"><span class="toc-number">1.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">我的代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98C"><span class="toc-number">2.</span> <span class="toc-text">问题C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98D"><span class="toc-number">2.1.</span> <span class="toc-text">问题D</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98E"><span class="toc-number">3.</span> <span class="toc-text">问题E</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98F"><span class="toc-number">4.</span> <span class="toc-text">问题F</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
<script type="text/javascript" src="../source/js/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="../source/js/codeBlock/codeBLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="../source/js/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="../source/js/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="../source/js/codeBlock/codeShrink.js"></script>
<!-- 代码块折行 -->
<style type="text/css">
    code[class*="language-"],
    pre[class*="language-"] {
        white-space: pre !important;
    }

</style>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
